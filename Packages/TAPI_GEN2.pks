CREATE OR REPLACE PACKAGE tapi_gen2 authid current_user
AS

   /**
   * TAPI_GEN2
   * Generated by: Oscar Salvador Magallanes
   * Website: github.com/osalvador/tapiGen2
   * Created On: 16-JUL-2015
   */

   --Global public data structures
   SUBTYPE dbo_name_t IS VARCHAR2 (30); -- Max size for a DB object name

   TYPE dbo_name_aat IS TABLE OF dbo_name_t;

    TYPE column_rt
    IS
      RECORD (
         table_name        user_tab_columns.table_name%TYPE
       , column_name       user_tab_columns.column_name%TYPE
       , nullable          user_tab_columns.nullable%TYPE
       , constraint_type   user_constraints.constraint_type%TYPE
      );

   --Collection types (record)
   TYPE column_tt IS TABLE OF column_rt;

   TYPE constraint_tt IS TABLE OF user_constraints%ROWTYPE;

   /**
   * Create PL/SQL Table API
   *   
   * @param     p_table_name              must be NOT NULL
   * @param     p_compile_table_api       TRUE for compile generated package, FALSE to DBMS_OUTPUT the source
   * @param     p_unique_key              If the table has no primary key, it indicates the column that will be used as a unique key
   * @param     p_created_by_col_name     Custom audit column
   * @param     p_created_date_col_name   Custom audit column
   * @param     p_modified_by_col_name    Custom audit column
   * @param     p_modified_date_col_name  Custom audit column
   * @param     p_raise_exceptions        TRUE to use logger for exception handling
   */
   PROCEDURE create_tapi_package (p_table_name               IN VARCHAR2
                                , p_compile_table_api        IN BOOLEAN DEFAULT TRUE
                                , p_unique_key               IN VARCHAR2 DEFAULT NULL
                                , p_created_by_col_name      IN VARCHAR2 DEFAULT NULL
                                , p_created_date_col_name    IN VARCHAR2 DEFAULT NULL
                                , p_modified_by_col_name     IN VARCHAR2 DEFAULT NULL
                                , p_modified_date_col_name   IN VARCHAR2 DEFAULT NULL
                                , p_raise_exceptions         IN BOOLEAN DEFAULT FALSE);

   --Public functions but for internal use.
   FUNCTION get_all_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

   FUNCTION get_pk_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

   FUNCTION get_noblob_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

--Spec Template
$if false $then
<%@ template
    name=spec
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_cont in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_cont > 1
         then
               teplsql.p(p_delimiter);
         end if;
    end; %>
CREATE OR REPLACE PACKAGE tapi_${table_name}
IS
   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   <% for i in 1 .. col.last loop %>
   SUBTYPE <%= col(i).COLUMN_NAME%> IS ${table_name}.<%= col(i).COLUMN_NAME%>%TYPE;
   <% end loop; %>

   --Record type
   TYPE ${table_name}_rt
   IS
      RECORD (
           <% c := col.last+1;
           for i in 1 .. col.last loop %>
            <%=  col(i).COLUMN_NAME%> ${table_name}.<%=col(i).COLUMN_NAME %>%TYPE,
           <% end loop; %>
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE ${table_name}_tt IS TABLE OF ${table_name}_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   FUNCTION hash (
              <% c := pk.last+1;
                for i in 1 .. pk.last loop %>
                  p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   * 
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**   
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
             <% end loop; %>
               )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the ${table_name} table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt_for_update (
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
                      <% end loop; %>
                          )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   * This function return Record Table as PIPELINED Function
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Table Record Type   
   */
   FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
               )
   RETURN ${table_name}_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the ${table_name} table.
   *
   * @param      p_${table_name}_rec       Record Type
   * @return     p_${table_name}_rec       Record Type
   */
   PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table.    
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update    
   */   
   PROCEDURE upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table,
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update    
   */ 
   PROCEDURE upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update    
   */   
   PROCEDURE web_upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update    
   */  
   PROCEDURE web_upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */ 
   PROCEDURE del (
              <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table 
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */   
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation, access directly to the row by rowid
   *   
   * @param      p_rowid      must be NOT NULL   
   * @param      p_hash       must be NOT NULL   
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_${table_name};
$end


--Body Template
$if false $then
<%@ template
    name=body
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! noblob   tapi_gen2.column_tt := tapi_gen2.get_noblob_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_index in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_index > 1
         then
            teplsql.p(p_delimiter);
         end if;
    end; %>
<%! /*  User column for update */
   procedure column_for_update(p_column_name in varchar2,
                               p_ignore_nulls in boolean,
                               p_index in pls_integer,
                               p_blanks in pls_integer default 16)
   as
    l_blanks varchar2(256);
   begin
     for i in 1 .. p_blanks
     loop
        l_blanks := l_blanks ||' ';
     end loop;

      if ('${created_by_col_name}' <> p_column_name or '${created_by_col_name}' is null)
        and ('${created_date_col_name}' <> p_column_name or '${created_date_col_name}' is null)
     then
        if '${modified_by_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = USER /*dbax_core.g$username or apex_application.g_user*/');
        elsif '${modified_date_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = SYSDATE');
        else
           if p_ignore_nulls
           then
            teplsql.p(p_column_name || ' = ' || 'NVL(p_${table_name}_rec.'|| p_column_name ||','|| p_column_name ||')');
           else
            teplsql.p(p_column_name || ' = p_${table_name}_rec.' || p_column_name);
           end if;
        end if;

        sep(p_index,',\\n' || l_blanks);

     end if;
   end; %>
CREATE OR REPLACE PACKAGE BODY tapi_${table_name} IS

   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

  <% if '${raise_exceptions}' is not null then %>
    --Global logger scope
    gc_scope_prefix CONSTANT varchar2(31) := LOWER($$plsql_unit)||'.';
  <% end if; %>

   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ${table_name}_cur (
                    <% c := pk.last+1; for i in 1 .. pk.last loop %>
                       p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                    <% end loop; %>
                       )
   IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
            <%=col(i).column_name%>,
        <% end loop; %>
            tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
            ROWID
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = ${table_name}_cur.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

    --By Rowid
    CURSOR ${table_name}_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
             <%=col(i).column_name%>,
        <% end loop; %>
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             ROWID
      FROM ${table_name}
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                <% end loop; %>
                  )
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN

     <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
     <% end if; %>

     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
         <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = hash.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <%end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);
      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <%end if; %>
   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN
      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
      <% end if; %>

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
          <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <% end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>
      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END hash_rowid;

   FUNCTION rt (
            <% c := pk.last+1; for i in 1 .. pk.last loop %>
               p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
            <% end loop; %>
               )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt.p_<%=pk(i).column_name%><%sep(c-i,' AND ' );%>\\n
        <% end loop; %>
           ;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt;

   FUNCTION rt_for_update (
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                        <% end loop; %>
                          )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt_for_update';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt_for_update.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt_for_update;

    FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
                )
       RETURN ${table_name}_tt
       PIPELINED
    IS
       <% if '${raise_exceptions}' is not null then %>
       l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'tt';
       l_params logger.tab_param;
       <% end if; %>
       l_${table_name}_rec   ${table_name}_rt;
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', tt.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ${table_name} a
                   WHERE
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                        <%=pk(i).column_name%> = NVL(tt.p_<%=pk(i).column_name%>,<%=pk(i).column_name%>)<%sep(c-i,' AND ');%>\\n
                      <% end loop; %>
                        )
       LOOP
            <% for i in 1 .. col.last loop %>
              l_${table_name}_rec.<%=col(i).column_name%> := c1.<%=col(i).column_name%>;
            <% end loop; %>
              l_${table_name}_rec.hash := tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %> c1.<%=pk(i).column_name%><%sep(c-i,',');%><% end loop; %>);
              l_${table_name}_rec.row_id := c1.ROWID;
              PIPE ROW (l_${table_name}_rec);
       END LOOP;
       <% if '${raise_exceptions}' is not null then %>

       logger.LOG('END', l_scope);
       <% end if; %>

       RETURN;

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
    <% end if; %>
    END tt;


    PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt)
    IS
        <% if '${raise_exceptions}' is not null then %>
        l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'ins';
        l_params logger.tab_param;
       <% end if; %>
        l_rowtype     ${table_name}%ROWTYPE;
       <% if '${created_by_col_name}' is not null
        or   '${modified_by_col_name}' is not null
       then
            if '${created_by_col_name}' is not null
            then%>
        l_user_name   ${table_name}.${created_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <%else%>
        l_user_name   ${table_name}.${modified_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <% end if;
       end if;
       if '${created_date_col_name}' is not null
       or '${modified_date_col_name}' is not null
       then
            if '${created_date_col_name}' is not null
            then %>
        l_date        ${table_name}.${created_date_col_name}%TYPE := SYSDATE;
            <%else%>
        l_date        ${table_name}.${modified_date_col_name}%TYPE := SYSDATE;
            <% end if;
       end if; %>

    BEGIN
        <% if '${raise_exceptions}' is not null then
          for i in 1 .. col.last loop %>
        logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', ins.p_${table_name}_rec.<%=col(i).column_name%>);
        <% end loop; %>
        logger.LOG('START', l_scope, NULL, l_params);
        logger.LOG('Inserting data', l_scope);
        <% end if;%>

        <% if '${created_by_col_name}'Is not null then%>
        p_${table_name}_rec.${created_by_col_name} := l_user_name;
        <% end if; %>!\n
        <% if '${created_date_col_name}' is not null then %>
        p_${table_name}_rec.${created_date_col_name} := l_date;
        <% end if; %>!\n
        <% if '${modified_by_col_name}' is not null then %>
        p_${table_name}_rec.${modified_by_col_name} := l_user_name;
        <% end if;%>!\n
        <% if '${modified_date_col_name}' is not null then %>
        p_${table_name}_rec.${modified_date_col_name} := l_date;
        <% end if; %>

        <% for i in 1 .. col.last loop %>
        l_rowtype.<%=col(i).column_name%> := ins.p_${table_name}_rec.<%=col(i).column_name%>;
        <% end loop; %>

       INSERT INTO ${table_name}
         VALUES   l_rowtype;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
      WHEN OTHERS
      THEN
         logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
         RAISE;
    <% end if; %>
    END ins;

    PROCEDURE upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,false,c-i);
                 end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
      <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
      <% end if; %>
    END upd;


    PROCEDURE upd_rowid (
                         p_${table_name}_rec         IN ${table_name}_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,false,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END upd_rowid;

   PROCEDURE web_upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                             web_upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                        <% end loop; %>
                        );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,true,c-i, 23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            END IF;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_${table_name}_rec    IN ${table_name}_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_upd_rowid.p_${table_name}_rec.row_id);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,true,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            END IF;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd_rowid;

    PROCEDURE del (
               <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
               <% end loop; %>
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

       DELETE FROM   ${table_name}
             WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  <%=pk(i).column_name%> = del.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
       <% if '${raise_exceptions}' is not null then %>
       logger.append_param(l_params, 'p_rowid', del_rowid.p_rowid);
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Deleting record', l_scope);
       <% end if; %>

       DELETE FROM   ${table_name}
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del_rowid;

    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', web_del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                          <% c := pk.last+1; for i in 1 .. pk.last loop %>
                            web_del.p_<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                          <% end loop; %>
                            );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_cur;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;


      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', web_del_rowid.p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_del_rowid.p_rowid);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_rowid_cur;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

     <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
     <%end if; %>
   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del_rowid;

END tapi_${table_name};

$end

END tapi_gen2;
/
