--
-- Script was generated by Devart dbForge Studio for Oracle, Version 3.7.472.0
-- Product home page: http://www.devart.com/dbforge/oracle/studio
-- Script date 7/19/2016 12:57:53 PM
-- Server version: Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options
-- Client version: 12.1.0.0
--


CONNECT simple_delivery/123456@pdborcl;


--
-- Set default schema
--
ALTER SESSION SET CURRENT_SCHEMA = "SIMPLE_DELIVERY";

SET SQLBLANKLINES ON;
SET DEFINE OFF;
ALTER SESSION SET NLS_DATE_FORMAT = 'MM/DD/SYYYY HH24:MI:SS';
ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF';
ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,';
ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE;
ALTER SESSION SET TIME_ZONE = '-05:00';

--
-- Definition for sequence LOGGER_APX_ITEMS_SEQ
--
CREATE SEQUENCE logger_apx_items_seq
START WITH 1
INCREMENT BY 1;

--
-- Definition for sequence LOGGER_LOGS_SEQ
--
CREATE SEQUENCE logger_logs_seq
START WITH 21
INCREMENT BY 1;

--
-- Definition for table LOGGER_LOGS
--
CREATE TABLE LOGGER_LOGS (
  ID NUMBER,
  LOGGER_LEVEL NUMBER NOT NULL,
  TEXT VARCHAR2(4000 BYTE),
  TIME_STAMP TIMESTAMP(6) NOT NULL,
  SCOPE VARCHAR2(1000 BYTE),
  MODULE VARCHAR2(100 BYTE),
  ACTION VARCHAR2(100 BYTE),
  USER_NAME VARCHAR2(255 BYTE),
  CLIENT_IDENTIFIER VARCHAR2(255 BYTE),
  CALL_STACK VARCHAR2(4000 BYTE),
  UNIT_NAME VARCHAR2(255 BYTE),
  LINE_NO VARCHAR2(100 BYTE),
  SCN NUMBER,
  EXTRA CLOB,
  SID NUMBER,
  CLIENT_INFO VARCHAR2(64 BYTE),
  CONSTRAINT LOGGER_LOGS_LVL_CK CHECK (logger_level in (1,2,4,8,16,32,64,128)),
  CONSTRAINT LOGGER_LOGS_PK PRIMARY KEY (ID) USING INDEX STORAGE ( INITIAL 64K NEXT 1M MAXEXTENTS UNLIMITED ))
LOGGING;

CREATE INDEX logger_logs_idx1 ON logger_logs (time_stamp, logger_level)
LOGGING;

--
-- Definition for table LOGGER_PREFS
--
CREATE TABLE logger_prefs (
  pref_name  VARCHAR2(255 BYTE),
  pref_value VARCHAR2(255 BYTE) NOT NULL,
  pref_type  VARCHAR2(30 BYTE)  NOT NULL,
  CONSTRAINT logger_prefs_ck1 CHECK (pref_name = UPPER(pref_name)),
  CONSTRAINT logger_prefs_ck2 CHECK (pref_type = UPPER(pref_type)),
  CONSTRAINT logger_prefs_pk PRIMARY KEY (pref_type, pref_name) USING INDEX STORAGE (INITIAL 64 K
                                                                                     NEXT 1 M
                                                                                     MAXEXTENTS UNLIMITED)
)
LOGGING;

--
-- Definition for table LOGGER_PREFS_BY_CLIENT_ID
--
CREATE TABLE logger_prefs_by_client_id (
  client_id          VARCHAR2(64 BYTE) NOT NULL,
  logger_level       VARCHAR2(20 BYTE) NOT NULL,
  include_call_stack VARCHAR2(5 BYTE)  NOT NULL,
  created_date       DATE              DEFAULT sysdate NOT NULL,
  expiry_date        DATE              NOT NULL,
  CONSTRAINT logger_prefs_by_client_id_ck1 CHECK (logger_level IN ('OFF', 'PERMANENT', 'ERROR', 'WARNING', 'INFORMATION', 'DEBUG', 'TIMING', 'APEX', 'SYS_CONTEXT')),
  CONSTRAINT logger_prefs_by_client_id_ck2 CHECK (expiry_date >= created_date),
  CONSTRAINT logger_prefs_by_client_id_ck3 CHECK (include_call_stack IN ('TRUE', 'FALSE')),
  CONSTRAINT logger_prefs_by_client_id_pk PRIMARY KEY (client_id)
)
LOGGING;

COMMENT ON TABLE logger_prefs_by_client_id IS 'Client specific logger levels. Only active client_ids/logger_levels will be maintained in this table';
COMMENT ON COLUMN logger_prefs_by_client_id.client_id IS 'Client identifier';
COMMENT ON COLUMN logger_prefs_by_client_id.created_date IS 'Date that entry was created on';
COMMENT ON COLUMN logger_prefs_by_client_id.expiry_date IS 'After the given expiry date the logger_level will be disabled for the specific client_id. Unless sepcifically removed from this table a job will clean up old entries';
COMMENT ON COLUMN logger_prefs_by_client_id.include_call_stack IS 'Include call stack in logging';
COMMENT ON COLUMN logger_prefs_by_client_id.logger_level IS 'Logger level. Must be OFF, PERMANENT, ERROR, WARNING, INFORMATION, DEBUG, TIMING';

--
-- Definition for table TE_TEMPLATES
--
CREATE TABLE te_templates (
  name          VARCHAR2(300 BYTE),
  template      CLOB,
  description   VARCHAR2(300 BYTE),
  created_by    VARCHAR2(100 BYTE) DEFAULT USER NOT NULL,
  created_date  DATE               DEFAULT sysdate NOT NULL,
  modified_by   VARCHAR2(100 BYTE) DEFAULT USER NOT NULL,
  modified_date DATE               DEFAULT sysdate NOT NULL,
  CONSTRAINT te_templates_pk PRIMARY KEY (name)
)
LOGGING;

--
-- Definition for table LOGGER_LOGS_APEX_ITEMS
--
CREATE TABLE logger_logs_apex_items (
  id          NUMBER              NOT NULL,
  log_id      NUMBER              NOT NULL,
  app_session NUMBER              NOT NULL,
  item_name   VARCHAR2(1000 BYTE) NOT NULL,
  item_value  CLOB,
  CONSTRAINT logger_logs_apx_itms_pk PRIMARY KEY (id),
  CONSTRAINT logger_logs_apx_itms_fk FOREIGN KEY (log_id)
  REFERENCES logger_logs (id) ON DELETE CASCADE
)
LOGGING;

CREATE INDEX logger_apex_items_idx1 ON logger_logs_apex_items (log_id)
LOGGING;

--
-- Definition for package LOGGER
--
CREATE OR REPLACE PACKAGE logger
AUTHID DEFINER
  AS
  -- This project using the following MIT License:
  --
  -- The MIT License (MIT)
  --
  -- Copyright (c) 2015 OraOpenSource
  --
  -- Permission is hereby granted, free of charge, to any person obtaining a copy
  -- of this software and associated documentation files (the "Software"), to deal
  -- in the Software without restriction, including without limitation the rights
  -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  -- copies of the Software, and to permit persons to whom the Software is
  -- furnished to do so, subject to the following conditions:
  --
  -- The above copyright notice and this permission notice shall be included in all
  -- copies or substantial portions of the Software.
  --
  -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  -- SOFTWARE.


  -- TYPES
  TYPE rec_param IS RECORD (
      name VARCHAR2(255),
      val  VARCHAR2(4000)
    );

  TYPE tab_param IS TABLE OF rec_param
    INDEX BY BINARY_INTEGER;

  TYPE rec_logger_log IS RECORD (
      id           logger_logs.id % TYPE,
      logger_level logger_logs.logger_level % TYPE
    );


  -- VARIABLES
  g_logger_version CONSTANT VARCHAR2(10) := '3.1.0'; -- Don't change this. Build script will replace with right version number
  g_context_name CONSTANT VARCHAR2(35) := SUBSTR(SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'), 1, 23) || '_LOGCTX';

  g_off CONSTANT NUMBER := 0;
  g_permanent CONSTANT NUMBER := 1;
  g_error CONSTANT NUMBER := 2;
  g_warning CONSTANT NUMBER := 4;
  g_information CONSTANT NUMBER := 8;
  g_debug CONSTANT NUMBER := 16;
  g_timing CONSTANT NUMBER := 32;
  g_sys_context CONSTANT NUMBER := 64;
  g_apex CONSTANT NUMBER := 128;

  -- #44
  g_off_name CONSTANT VARCHAR2(30) := 'OFF';
  g_permanent_name CONSTANT VARCHAR2(30) := 'PERMANENT';
  g_error_name CONSTANT VARCHAR2(30) := 'ERROR';
  g_warning_name CONSTANT VARCHAR2(30) := 'WARNING';
  g_information_name CONSTANT VARCHAR2(30) := 'INFORMATION';
  g_debug_name CONSTANT VARCHAR2(30) := 'DEBUG';
  g_timing_name CONSTANT VARCHAR2(30) := 'TIMING';
  g_sys_context_name CONSTANT VARCHAR2(30) := 'SYS_CONTEXT';
  g_apex_name CONSTANT VARCHAR2(30) := 'APEX';

  gc_empty_tab_param tab_param;

  -- #54: Types for log_apex_items
  g_apex_item_type_all CONSTANT VARCHAR2(30) := 'ALL'; -- Application items and page items
  g_apex_item_type_app CONSTANT VARCHAR2(30) := 'APP'; -- All application items
  g_apex_item_type_page CONSTANT VARCHAR2(30) := 'PAGE'; -- All page items
  -- To log items on a particular page, just enter the page number

  -- #127
  -- Note to developers: This is only for internal Logger code. Do not use this as part of your code.
  g_pref_type_logger CONSTANT logger_prefs.pref_type % TYPE := 'LOGGER'; -- If this changes need to modify logger_prefs.sql as it has a dependancy.

  -- Expose private functions only for testing during development
  $if $$logger_debug $then
    function is_number(p_str in varchar2)
      return boolean;

    procedure assert(
      p_condition in boolean,
      p_message in varchar2);

    function get_param_clob(p_params in logger.tab_param)
      return clob;

    procedure save_global_context(
      p_attribute in varchar2,
      p_value in varchar2,
      p_client_id in varchar2 default null);

    function set_extra_with_params(
      p_extra in logger_logs.extra%type,
      p_params in tab_param)
      return logger_logs.extra%type;

    function get_sys_context(
      p_detail_level in varchar2 default 'USER', -- ALL, NLS, USER, INSTANCE
      p_vertical in boolean default false,
      p_show_null in boolean default false)
      return clob;

    function admin_security_check
      return boolean;

    function get_level_number
      return number;

    function include_call_stack
      return boolean;

    function date_text_format_base (
      p_date_start in date,
      p_date_stop  in date)
      return varchar2;

    procedure log_internal(
      p_text in varchar2,
      p_log_level in number,
      p_scope in varchar2,
      p_extra in clob default null,
      p_callstack in varchar2 default null,
      p_params in tab_param default logger.gc_empty_tab_param);
  $end

  -- PROCEDURES and FUNCTIONS

  PROCEDURE null_global_contexts;

  FUNCTION convert_level_char_to_num(p_level IN VARCHAR2)
    RETURN NUMBER;

  FUNCTION convert_level_num_to_char(p_level IN NUMBER)
    RETURN VARCHAR2;

  FUNCTION date_text_format(p_date IN DATE)
    RETURN VARCHAR2;

  FUNCTION get_character_codes(p_string            IN VARCHAR2,
                               p_show_common_codes IN BOOLEAN DEFAULT TRUE)
    RETURN VARCHAR2;

  PROCEDURE log_error(p_text   IN VARCHAR2  DEFAULT NULL,
                      p_scope  IN VARCHAR2  DEFAULT NULL,
                      p_extra  IN CLOB      DEFAULT NULL,
                      p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log_permanent(p_text   IN VARCHAR2,
                          p_scope  IN VARCHAR2  DEFAULT NULL,
                          p_extra  IN CLOB      DEFAULT NULL,
                          p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log_warning(p_text   IN VARCHAR2,
                        p_scope  IN VARCHAR2  DEFAULT NULL,
                        p_extra  IN CLOB      DEFAULT NULL,
                        p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log_warn(p_text   IN VARCHAR2,
                     p_scope  IN VARCHAR2  DEFAULT NULL,
                     p_extra  IN CLOB      DEFAULT NULL,
                     p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log_information(p_text   IN VARCHAR2,
                            p_scope  IN VARCHAR2  DEFAULT NULL,
                            p_extra  IN CLOB      DEFAULT NULL,
                            p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log_info(p_text   IN VARCHAR2,
                     p_scope  IN VARCHAR2  DEFAULT NULL,
                     p_extra  IN CLOB      DEFAULT NULL,
                     p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  PROCEDURE log(p_text   IN VARCHAR2,
                p_scope  IN VARCHAR2  DEFAULT NULL,
                p_extra  IN CLOB      DEFAULT NULL,
                p_params IN tab_param DEFAULT logger.gc_empty_tab_param);

  FUNCTION get_cgi_env(p_show_null IN BOOLEAN DEFAULT FALSE)
    RETURN CLOB;

  PROCEDURE log_userenv(p_detail_level IN VARCHAR2                        DEFAULT 'USER',-- ALL, NLS, USER, INSTANCE,
                        p_show_null    IN BOOLEAN                         DEFAULT FALSE,
                        p_scope        IN logger_logs.scope % TYPE        DEFAULT NULL,
                        p_level        IN logger_logs.logger_level % TYPE DEFAULT NULL);

  PROCEDURE log_cgi_env(p_show_null IN BOOLEAN                         DEFAULT FALSE,
                        p_scope     IN logger_logs.scope % TYPE        DEFAULT NULL,
                        p_level     IN logger_logs.logger_level % TYPE DEFAULT NULL);

  PROCEDURE log_character_codes(p_text              IN VARCHAR2,
                                p_scope             IN logger_logs.scope % TYPE        DEFAULT NULL,
                                p_show_common_codes IN BOOLEAN                         DEFAULT TRUE,
                                p_level             IN logger_logs.logger_level % TYPE DEFAULT NULL);

  PROCEDURE log_apex_items(p_text           IN VARCHAR2                        DEFAULT 'Log APEX Items',
                           p_scope          IN logger_logs.scope % TYPE        DEFAULT NULL,
                           p_item_type      IN VARCHAR2                        DEFAULT logger.g_apex_item_type_all,
                           p_log_null_items IN BOOLEAN                         DEFAULT TRUE,
                           p_level          IN logger_logs.logger_level % TYPE DEFAULT NULL);

  PROCEDURE time_start(p_unit         IN VARCHAR2,
                       p_log_in_table IN BOOLEAN DEFAULT TRUE);

  PROCEDURE time_stop(p_unit  IN VARCHAR2,
                      p_scope IN VARCHAR2 DEFAULT NULL);

  FUNCTION time_stop(p_unit         IN VARCHAR2,
                     p_scope        IN VARCHAR2 DEFAULT NULL,
                     p_log_in_table IN BOOLEAN  DEFAULT TRUE)
    RETURN VARCHAR2;

  FUNCTION time_stop_seconds(p_unit         IN VARCHAR2,
                             p_scope        IN VARCHAR2 DEFAULT NULL,
                             p_log_in_table IN BOOLEAN  DEFAULT TRUE)
    RETURN NUMBER;

  PROCEDURE time_reset;

  FUNCTION get_pref(p_pref_name IN logger_prefs.pref_name % TYPE,
                    p_pref_type IN logger_prefs.pref_type % TYPE DEFAULT logger.g_pref_type_logger)
    RETURN VARCHAR2
  $if not dbms_db_version.ver_le_10_2  $then
    result_cache
  $end;

  -- #103
  PROCEDURE set_pref(p_pref_type  IN logger_prefs.pref_type % TYPE,
                     p_pref_name  IN logger_prefs.pref_name % TYPE,
                     p_pref_value IN logger_prefs.pref_value % TYPE);

  -- #103
  PROCEDURE del_pref(p_pref_type IN logger_prefs.pref_type % TYPE,
                     p_pref_name IN logger_prefs.pref_name % TYPE);

  PROCEDURE purge(p_purge_after_days IN VARCHAR2 DEFAULT NULL,
                  p_purge_min_level  IN VARCHAR2 DEFAULT NULL);

  PROCEDURE purge(p_purge_after_days IN NUMBER DEFAULT NULL,
                  p_purge_min_level  IN NUMBER);

  PROCEDURE purge_all;

  PROCEDURE status(p_output_format IN VARCHAR2 DEFAULT NULL); -- SQL-DEVELOPER | HTML | DBMS_OUPUT

  PROCEDURE sqlplus_format;

  PROCEDURE set_level(p_level                  IN VARCHAR2 DEFAULT logger.g_debug_name,
                      p_client_id              IN VARCHAR2 DEFAULT NULL,
                      p_include_call_stack     IN VARCHAR2 DEFAULT NULL,
                      p_client_id_expire_hours IN NUMBER   DEFAULT NULL);

  PROCEDURE unset_client_level(p_client_id IN VARCHAR2);

  PROCEDURE unset_client_level;

  PROCEDURE unset_client_level_all;


  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            VARCHAR2);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            NUMBER);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            DATE);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            TIMESTAMP);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            TIMESTAMP WITH TIME ZONE);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            TIMESTAMP WITH LOCAL TIME ZONE);

  PROCEDURE append_param(p_params IN OUT NOCOPY logger.tab_param,
                         p_name   IN            VARCHAR2,
                         p_val    IN            BOOLEAN);

  FUNCTION ok_to_log(p_level IN NUMBER)
    RETURN BOOLEAN;

  FUNCTION ok_to_log(p_level IN VARCHAR2)
    RETURN BOOLEAN;

  FUNCTION tochar(p_val IN NUMBER)
    RETURN VARCHAR2;

  FUNCTION tochar(p_val IN DATE)
    RETURN VARCHAR2;

  FUNCTION tochar(p_val IN TIMESTAMP)
    RETURN VARCHAR2;

  FUNCTION tochar(p_val IN TIMESTAMP WITH TIME ZONE)
    RETURN VARCHAR2;

  FUNCTION tochar(p_val IN TIMESTAMP WITH LOCAL TIME ZONE)
    RETURN VARCHAR2;

  FUNCTION tochar(p_val IN BOOLEAN)
    RETURN VARCHAR2;

  PROCEDURE ins_logger_logs(p_logger_level IN         logger_logs.logger_level % TYPE,
                            p_text         IN         VARCHAR2                      DEFAULT NULL, -- Not using type since want to be able to pass in 32767 characters
                            p_scope        IN         logger_logs.scope % TYPE      DEFAULT NULL,
                            p_call_stack   IN         logger_logs.call_stack % TYPE DEFAULT NULL,
                            p_unit_name    IN         logger_logs.unit_name % TYPE  DEFAULT NULL,
                            p_line_no      IN         logger_logs.line_no % TYPE    DEFAULT NULL,
                            p_extra        IN         logger_logs.extra % TYPE      DEFAULT NULL,
                            po_id          OUT NOCOPY logger_logs.id % TYPE);


  FUNCTION sprintf(p_str IN VARCHAR2,
                   p_s1  IN VARCHAR2 DEFAULT NULL,
                   p_s2  IN VARCHAR2 DEFAULT NULL,
                   p_s3  IN VARCHAR2 DEFAULT NULL,
                   p_s4  IN VARCHAR2 DEFAULT NULL,
                   p_s5  IN VARCHAR2 DEFAULT NULL,
                   p_s6  IN VARCHAR2 DEFAULT NULL,
                   p_s7  IN VARCHAR2 DEFAULT NULL,
                   p_s8  IN VARCHAR2 DEFAULT NULL,
                   p_s9  IN VARCHAR2 DEFAULT NULL,
                   p_s10 IN VARCHAR2 DEFAULT NULL)
    RETURN VARCHAR2;

  FUNCTION get_plugin_rec(p_logger_level IN logger_logs.logger_level % TYPE)
    RETURN logger.rec_logger_log;
END logger;
/

CREATE OR REPLACE PACKAGE BODY logger
  AS
  -- Note: The license is defined in the package specification of the logger package
  --
  -- Conditional Compilation variables:
  -- $$NO_OP
  --  When true, completely disables all logger DML.Also used to generate the logger_no_op.sql file
  --
  -- $$RAC_LT_11_2:
  --  Set in logger_configure.
  --  Handles the fact that RAC doesn't support global app contexts until 11.2
  --
  -- $$FLASHBACK_ENABLED
  --  Set in logger_configure.
  --  Determine whether or not we can grab the scn from dbms_flashback.
  --  Primarily used in the trigger on logger_logs.
  --
  -- $$APEX
  --  Set in logger_configure.
  --  True if we can query a local synonym to wwv_flow_data to snapshot the APEX session state.
  --
  -- $$LOGGER_DEBUG
  --  Only to be used during development of logger
  --  Primarily used for dbms_output.put_line calls
  --  Part of #64
  --
  -- $$LOGGER_PLUGIN_<TYPE> : For each type of plugin
  --  Introduced with #46
  --  $$LOGGER_PLUGIN_ERROR
  --


  -- TYPES
  TYPE ts_array IS TABLE OF TIMESTAMP
    INDEX BY VARCHAR2 (100);


  -- VARIABLES
  g_log_id NUMBER;
  g_proc_start_times ts_array;
  g_running_timers PLS_INTEGER := 0;

  -- #46
  g_plug_logger_log_error rec_logger_log;

  g_in_plugin_error BOOLEAN := FALSE;






  -- CONSTANTS
  gc_line_feed CONSTANT VARCHAR2(1) := CHR(10);
  gc_cflf CONSTANT VARCHAR2(2) := CHR(13) || CHR(10);
  gc_date_format CONSTANT VARCHAR2(255) := 'DD-MON-YYYY HH24:MI:SS';
  gc_timestamp_format CONSTANT VARCHAR2(255) := gc_date_format || ':FF';
  gc_timestamp_tz_format CONSTANT VARCHAR2(255) := gc_timestamp_format || ' TZR';

  gc_ctx_attr_level CONSTANT VARCHAR2(5) := 'level';
  gc_ctx_attr_include_call_stack CONSTANT VARCHAR2(18) := 'include_call_stack';

  -- #46 Plugin context names
  gc_ctx_plugin_fn_log CONSTANT VARCHAR2(30) := 'plugin_fn_log';
  gc_ctx_plugin_fn_info CONSTANT VARCHAR2(30) := 'plugin_fn_information';
  gc_ctx_plugin_fn_warn CONSTANT VARCHAR2(30) := 'plugin_fn_warning';
  gc_ctx_plugin_fn_error CONSTANT VARCHAR2(30) := 'plugin_fn_error';
  gc_ctx_plugin_fn_perm CONSTANT VARCHAR2(30) := 'plugin_fn_permanent';

  -- #113 Preference names
  gc_pref_level CONSTANT logger_prefs.pref_name % TYPE := 'LEVEL';
  gc_pref_include_call_stack CONSTANT logger_prefs.pref_name % TYPE := 'INCLUDE_CALL_STACK';
  gc_pref_protect_admin_procs CONSTANT logger_prefs.pref_name % TYPE := 'PROTECT_ADMIN_PROCS';
  gc_pref_install_schema CONSTANT logger_prefs.pref_name % TYPE := 'INSTALL_SCHEMA';
  gc_pref_purge_after_days CONSTANT logger_prefs.pref_name % TYPE := 'PURGE_AFTER_DAYS';
  gc_pref_purge_min_level CONSTANT logger_prefs.pref_name % TYPE := 'PURGE_MIN_LEVEL';
  gc_pref_logger_version CONSTANT logger_prefs.pref_name % TYPE := 'LOGGER_VERSION';
  gc_pref_client_id_expire_hours CONSTANT logger_prefs.pref_name % TYPE := 'PREF_BY_CLIENT_ID_EXPIRE_HOURS';
  gc_pref_logger_debug CONSTANT logger_prefs.pref_name % TYPE := 'LOGGER_DEBUG';
  gc_pref_plugin_fn_error CONSTANT logger_prefs.pref_name % TYPE := 'PLUGIN_FN_ERROR';




  -- *** PRIVATE ***

  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created
   * @param p_str
   * @return True if p_str is a number
   */
  FUNCTION is_number(p_str IN VARCHAR2)
    RETURN BOOLEAN
  AS
    l_num NUMBER;
  BEGIN
    l_num := TO_NUMBER(p_str);
    RETURN TRUE;
  EXCEPTION
    WHEN OTHERS THEN
        RETURN FALSE;
  END is_number;


  /**
   * Validates assertion. Will raise an application error if assertion is false
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 29-Mar-2013
   * @param p_condition Boolean condition to validate
   * @param p_message Message to include in application error if p_condition fails
   */
  PROCEDURE assert(p_condition IN BOOLEAN,
                   p_message   IN VARCHAR2)
  AS
  BEGIN
  $if $$no_op $then
    null;
  $else
    if not p_condition or p_condition is null then
      raise_application_error(-20000, p_message);
    end if;
  $end
  END assert;


  /**
   * Returns the display/print friendly parameter information
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 20-Jan-2013
   * @param p_parms Array of parameters (can be null)
   * @return Clob of param information
   */
  FUNCTION get_param_clob(p_params IN logger.tab_param)
    RETURN CLOB
  AS
    l_return           CLOB;
    l_no_vars CONSTANT VARCHAR2(255) := 'No params defined';
    l_index            PLS_INTEGER;
  BEGIN

  $if $$no_op $then
    return null;
  $else
    -- Generate line feed delimited list
    if p_params.count > 0 then
      -- Using while true ... option allows for unordered param list
      l_index := p_params.first;
      while true loop
        l_return := l_return || p_params(l_index).name || ': ' || p_params(l_index).val;

        l_index := p_params.next(l_index);

        if l_index is null then
          exit;
        else
          l_return := l_return || gc_line_feed;
        end if;
      end loop;

    else
      -- No Parameters
      l_return := l_no_vars;
    end if;

    return l_return;
  $end
  END get_param_clob;



  /**
   * Sets the global context
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_attribute Attribute for context to set
   * @param p_value Value
   * @param p_client_id Optional client_id. If specified will only set the attribute/value for specific client_id (not global)
   */
  PROCEDURE save_global_context(p_attribute IN VARCHAR2,
                                p_value     IN VARCHAR2,
                                p_client_id IN VARCHAR2 DEFAULT NULL)
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    $if $$no_op $then
      null;
    $else
      dbms_session.set_context(
        namespace => g_context_name,
        attribute => p_attribute,
        value => p_value,
        client_id => p_client_id);
    $end

    COMMIT; -- MD: moved commit to outside of the NO_OP check since commit or rollback must occur in this procedure
  END save_global_context;



  /**
   * Will return the extra column appended with the display friendly parameters
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 1-May-2013
   * @param p_extra Current "Extra" field
   * @param p_params Parameters. If null, then no changes to the Extra column
   */
  FUNCTION set_extra_with_params(p_extra  IN logger_logs.extra % TYPE,
                                 p_params IN tab_param)
    RETURN logger_logs.extra % TYPE
  AS
    l_extra logger_logs.extra % TYPE;
  BEGIN
  $if $$no_op $then
    return null;
  $else
    if p_params.count = 0 then
      return p_extra;
    else
      l_extra := p_extra || gc_line_feed || gc_line_feed || '*** Parameters ***' || gc_line_feed || gc_line_feed || get_param_clob(p_params => p_params);
    end if;

    return l_extra;
  $end

  END set_extra_with_params;


  /**
   * Returns common system level context values
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, USER, or INSTANCe
   * @param p_vertical True of values should have a line break after each value. False for comman seperated list.
   * @param p_show_null Show null values
   * @return
   */
  FUNCTION get_sys_context(p_detail_level IN VARCHAR2 DEFAULT 'USER', -- ALL, NLS, USER, INSTANCE
                           p_vertical     IN BOOLEAN  DEFAULT FALSE,
                           p_show_null    IN BOOLEAN  DEFAULT FALSE)
    RETURN CLOB
  IS
    l_ctx          CLOB;
    l_detail_level VARCHAR2(20) := UPPER(p_detail_level);

    PROCEDURE append_ctx(p_name IN VARCHAR2)
    IS
      r_pad                NUMBER := 30;
      l_value              VARCHAR2(100);

      invalid_userenv_parm EXCEPTION;
      PRAGMA EXCEPTION_INIT (invalid_userenv_parm, -2003);

    BEGIN
      l_value := SYS_CONTEXT('USERENV', p_name);

      IF p_show_null
        OR l_value IS NOT NULL
      THEN
        IF p_vertical
        THEN
          l_ctx := l_ctx || RPAD(p_name, r_pad, ' ') || ': ' || l_value || gc_cflf;
        ELSE
          l_ctx := l_ctx || p_name || ': ' || l_value || ', ';
        END IF;
      END IF;
    EXCEPTION
      WHEN invalid_userenv_parm THEN
          NULL;
    END append_ctx;


  BEGIN
  $if $$no_op $then
    return null;
  $else
    if l_detail_level in ('ALL','NLS','INSTANCE') then
      append_ctx('NLS_CALENDAR');
      append_ctx('NLS_CURRENCY');
      append_ctx('NLS_DATE_FORMAT');
      append_ctx('NLS_DATE_LANGUAGE');
      append_ctx('NLS_SORT');
      append_ctx('NLS_TERRITORY');
      append_ctx('LANG');
      append_ctx('LANGUAGE');
    end if;
    if l_detail_level in ('ALL','USER') then
      append_ctx('CURRENT_SCHEMA');
      append_ctx('SESSION_USER');
      append_ctx('OS_USER');
      append_ctx('CLIENT_IDENTIFIER');
      append_ctx('CLIENT_INFO');
      append_ctx('IP_ADDRESS');
      append_ctx('HOST');
      append_ctx('TERMINAL');
    end if;

    if l_detail_level in ('ALL','USER') then
      append_ctx('AUTHENTICATED_IDENTITY');
      append_ctx('AUTHENTICATION_DATA');
      append_ctx('AUTHENTICATION_METHOD');
      append_ctx('ENTERPRISE_IDENTITY');
      append_ctx('POLICY_INVOKER');
      append_ctx('PROXY_ENTERPRISE_IDENTITY');
      append_ctx('PROXY_GLOBAL_UID');
      append_ctx('PROXY_USER');
      append_ctx('PROXY_USERID');
      append_ctx('IDENTIFICATION_TYPE');
      append_ctx('ISDBA');
    end if;

    if l_detail_level in ('ALL','INSTANCE') then
      append_ctx('DB_DOMAIN');
      append_ctx('DB_NAME');
      append_ctx('DB_UNIQUE_NAME');
      append_ctx('INSTANCE');
      append_ctx('INSTANCE_NAME');
      append_ctx('SERVER_HOST');
      append_ctx('SERVICE_NAME');
    end if;

    if l_detail_level in ('ALL') then
      append_ctx('ACTION');
      append_ctx('AUDITED_CURSORID');
      append_ctx('BG_JOB_ID');
      append_ctx('CURRENT_BIND');
      append_ctx('CURRENT_SCHEMAID');
      append_ctx('CURRENT_SQL');
      append_ctx('CURRENT_SQLn');
      append_ctx('CURRENT_SQL_LENGTH');
      append_ctx('ENTRYID');
      append_ctx('FG_JOB_ID');
      append_ctx('GLOBAL_CONTEXT_MEMORY');
      append_ctx('GLOBAL_UID');
      append_ctx('MODULE');
      append_ctx('NETWORK_PROTOCOL');
      append_ctx('SESSION_USERID');
      append_ctx('SESSIONID');
      append_ctx('SID');
      append_ctx('STATEMENTID');
    end if;

    return rtrim(l_ctx,', ');
  $end
  END get_sys_context;


  /**
   * Checks if admin functions can be run
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return True if user can run admin procs.
   */
  FUNCTION admin_security_check
    RETURN BOOLEAN
  IS
    l_protect_admin_procs logger_prefs.pref_value % TYPE;
    l_return              BOOLEAN DEFAULT FALSE;
  BEGIN
    $if $$no_op $then
      l_return := true;
    $else
      l_protect_admin_procs := get_pref(logger.gc_pref_protect_admin_procs);
      if l_protect_admin_procs = 'TRUE' then
        if get_pref(logger.gc_pref_install_schema) = sys_context('USERENV','SESSION_USER') then
          l_return := true;
        else
          l_return := false;
          raise_application_error (-20000, 'You are not authorized to call this procedure. Change Logger pref: PROTECT_ADMIN_PROCS to false to avoid this.');
        end if;
      else
        l_return := true;
      end if;
    $end

    RETURN l_return;

  END admin_security_check;


  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  - #111 Use get_pref to remove duplicate code
   *
   * @author Tyler Muth
   * @created ???
   * @param
   * @return If client level specified will return it, otherwise global level.
   */
  FUNCTION get_level_number
    RETURN NUMBER
  $if $$rac_lt_11_2 $then
    $if not dbms_db_version.ver_le_10_2 $then
      result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
    $end
  $end
  IS
    l_level      NUMBER;
    l_level_char VARCHAR2(50);

  $if $$logger_debug $then
    l_scope varchar2(30) := 'get_level_number';
  $end

  BEGIN
  $if $$no_op $then
    return g_off;
  $else
    $if $$logger_debug $then
      dbms_output.put_line(l_scope || ': selecting logger_level');
    $end

    l_level := convert_level_char_to_num(logger.get_pref(logger.gc_pref_level));

    return l_level;
  $end
  END get_level_number;


  /**
   * Determines if callstack should be while logging
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return
   */
  FUNCTION include_call_stack
    RETURN BOOLEAN
  $if 1=1
    and $$rac_lt_11_2
    and not dbms_db_version.ver_le_10_2
    and ($$no_op is null or not $$no_op) $then
      result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
  $end
  IS
    l_call_stack_pref logger_prefs.pref_value % TYPE;
  BEGIN
  $if $$no_op $then
    return false;
  $else
    $if $$rac_lt_11_2 $then
      l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
    $else
      l_call_stack_pref := sys_context(g_context_name,gc_ctx_attr_include_call_stack);

      if l_call_stack_pref is null then
        l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
        save_global_context(
          p_attribute => gc_ctx_attr_include_call_stack,
          p_value => l_call_stack_pref,
          p_client_id => sys_context('userenv','client_identifier'));
      end if;
    $end

    if l_call_stack_pref = 'TRUE' then
      return true;
    else
      return false;
    end if;
  $end
  END include_call_stack;


  /**
   * Returns date diff in "... sectons/minutes/days/etc ago" format
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date_start
   * @param p_date_stop
   * @return Text version of date diff
   */
  FUNCTION date_text_format_base(p_date_start IN DATE,
                                 p_date_stop  IN DATE)
    RETURN VARCHAR2
  AS
    x VARCHAR2(20);
  BEGIN
  $if $$no_op $then
    return null;
  $else
    x :=
      case
        when p_date_stop-p_date_start < 1/1440
          then round(24*60*60*(p_date_stop-p_date_start)) || ' seconds'
        when p_date_stop-p_date_start < 1/24
          then round(24*60*(p_date_stop-p_date_start)) || ' minutes'
        when p_date_stop-p_date_start < 1
          then round(24*(p_date_stop-p_date_start)) || ' hours'
        when p_date_stop-p_date_start < 14
          then trunc(p_date_stop-p_date_start) || ' days'
        when p_date_stop-p_date_start < 60
          then trunc((p_date_stop-p_date_start)/7) || ' weeks'
        when p_date_stop-p_date_start < 365
          then round(months_between(p_date_stop,p_date_start)) || ' months'
        else round(months_between(p_date_stop,p_date_start)/12,1) || ' years'
      end;
    x:= regexp_replace(x,'(^1 [[:alnum:]]{4,10})s','\1');
    x:= x || ' ago';
    return substr(x,1,20);
  $end
  END date_text_format_base;


  /**
   * Parses the callstack to get unit and line number
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_callstack
   * @param o_unit
   * @param o_lineno
   */
  PROCEDURE get_debug_info(p_callstack IN  CLOB,
                           o_unit      OUT VARCHAR2,
                           o_lineno    OUT VARCHAR2)
  AS
    --
    l_callstack VARCHAR2(10000) := p_callstack;
  BEGIN
  $if $$no_op $then
    null;
  $else
    l_callstack := substr( l_callstack, instr( l_callstack, chr(10), 1, 5 )+1 );
    l_callstack := substr( l_callstack, 1, instr( l_callstack, chr(10), 1, 1 )-1 );
    l_callstack := trim( substr( l_callstack, instr( l_callstack, ' ' ) ) );
    o_lineno := substr( l_callstack, 1, instr( l_callstack, ' ' )-1 );
    o_unit := trim(substr( l_callstack, instr( l_callstack, ' ', -1, 1 ) ));
  $end
  END get_debug_info;


  /**
   * Main procedure that will store log data into logger_logs table
   *
   *
   * Modifications
   *  - 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_log_level
   * @param p_scope
   * @param p_extra
   * @param p_callstack
   * @param p_params
   *
   */
  PROCEDURE log_internal(p_text      IN VARCHAR2,
                         p_log_level IN NUMBER,
                         p_scope     IN VARCHAR2,
                         p_extra     IN CLOB      DEFAULT NULL,
                         p_callstack IN VARCHAR2  DEFAULT NULL,
                         p_params    IN tab_param DEFAULT logger.gc_empty_tab_param)
  IS
    l_proc_name VARCHAR2(100);
    l_lineno    VARCHAR2(100);
    l_text      VARCHAR2(32767);
    l_callstack VARCHAR2(3000);
    l_extra     logger_logs.extra % TYPE;
  BEGIN
  $if $$no_op $then
    null;
  $else
    l_text := p_text;

    -- Generate callstack text
    if p_callstack is not null and logger.include_call_stack then
      logger.get_debug_info(
        p_callstack => p_callstack,
        o_unit => l_proc_name,
        o_lineno => l_lineno);

      l_callstack  := regexp_replace(p_callstack,'^.*$','',1,4,'m');
      l_callstack  := regexp_replace(l_callstack,'^.*$','',1,1,'m');
      l_callstack  := ltrim(replace(l_callstack,chr(10)||chr(10),chr(10)),chr(10));

    end if;

    l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

    ins_logger_logs(
      p_unit_name => upper(l_proc_name) ,
      p_scope => p_scope ,
      p_logger_level =>p_log_level,
      p_extra => l_extra,
      p_text =>l_text,
      p_call_stack  =>l_callstack,
      p_line_no => l_lineno,
      po_id => g_log_id);
  $end
  END log_internal;


  /**
   * Run plugin
   *
   * Notes:
   *  - Currently only supports error type plugin but has been built to support other types
   *  - -- FUTURE mdsouza: When supporting other plugin types put conditional compilation where applicable
   *  - -- FUTURE mdsouza: Include this in tests (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_log Record that plugin should be run for
   */
  PROCEDURE run_plugin(p_logger_log IN logger.rec_logger_log)
  AS
    l_plugin_fn  logger_prefs.pref_value % TYPE;
    l_plugin_ctx VARCHAR2(30);

    l_sql        VARCHAR2(255);

    -- For exception block
    l_params     logger.tab_param;
    l_scope      logger_logs.scope % TYPE;

    -- Mark "in_plugin" as true/false
    -- Put in separate procedure since more logic may be applied
    -- And called from exception block as well
    PROCEDURE start_stop_plugin(p_in_plugin BOOLEAN -- True/False depending on action
    )
    AS
    BEGIN
      IF p_logger_log.logger_level = logger.g_error
      THEN
        g_in_plugin_error := p_in_plugin;
      END IF;
    END start_stop_plugin;

    FUNCTION f_get_set_global_context(p_ctx IN VARCHAR2)
      RETURN VARCHAR2
    AS
      l_return VARCHAR2(255);
    BEGIN
      $if $$logger_debug $then
        dbms_output.put_line('Calling f_get_set_global_conext');
      $end

      l_return := UPPER(get_pref(p_pref_name =>
      CASE WHEN p_logger_log.logger_level = g_error THEN gc_ctx_plugin_fn_error END
      ));

      $if $$logger_debug $then
        dbms_output.put_line('l_return: ' || l_return);
      $end

      save_global_context(p_attribute => p_ctx, p_value => l_return);
      RETURN l_return;
    END f_get_set_global_context;

  BEGIN
    start_stop_plugin(p_in_plugin => TRUE);

    $if $$logger_debug $then
      dbms_output.put_line('in run_plugin. g_in_plugin_error: ' || logger.tochar(g_in_plugin_error));
    $end

    IF 1 = 2
    THEN
      NULL;
    ELSIF p_logger_log.logger_level = logger.g_error
    THEN
      l_plugin_ctx := gc_ctx_plugin_fn_error;
    END IF;

    IF l_plugin_ctx IS NOT NULL
    THEN
      l_plugin_fn := COALESCE(
      SYS_CONTEXT(g_context_name, l_plugin_ctx),
      f_get_set_global_context(p_ctx => l_plugin_ctx));

      $if $$logger_debug $then
        dbms_output.put_line('l_plugin_fn: ' || l_plugin_fn);
      $end

      IF 1 = 1
        AND l_plugin_fn IS NOT NULL
        AND l_plugin_fn != 'NONE'
      THEN

        l_sql := 'begin ' || l_plugin_fn || '(logger.get_plugin_rec(' || p_logger_log.logger_level || ')); end;';

        $if $$logger_debug $then
          dbms_output.put_line('l_sql: ' || l_sql);
        $end

        EXECUTE IMMEDIATE l_sql;

      ELSE
        -- Should never reach this point since plugin_fn should have a value
        logger.log_error('Error l_plugin_fn does not have value');
      END IF; -- l_plugin_fn
    ELSE
      -- Should never reach this point since plugin_ctx should have a value
      logger.log_error('Error l_plugin_ctx does not have value');
    END IF; -- l_plugin_ctx is not null

    start_stop_plugin(p_in_plugin => FALSE);

  EXCEPTION
    WHEN OTHERS THEN
        logger.append_param(l_params, 'Logger.id', p_logger_log.id);
        logger.append_param(l_params, 'Logger.logger_level', p_logger_log.logger_level);
        logger.append_param(l_params, 'Plugin Function', l_plugin_fn);

        SELECT scope
          INTO l_scope
          FROM logger_logs_5_min
          WHERE 1 = 1
            AND id = p_logger_log.id;

        logger.log_error('Exception in plugin procedure: ' || l_plugin_fn, l_scope, NULL, l_params);

        start_stop_plugin(p_in_plugin => FALSE);

        RAISE;
  END run_plugin;




  -- **** PUBLIC ****


  /**
   * Sets all the contexts to null
   *
   * Notes:
   *  - Though this is public it is not a documented procedure. Only used with logger_configure.
   *
   * Related Tickets:
   *  - #46 Plugin support
   *  - #110 Clear all contexts (including ones with client identifier)
   *
   * @author Tyler Muth
   * @created ???
   */
  PROCEDURE null_global_contexts
  IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    $if $$no_op or $$rac_lt_11_2 $then
      null;
    $else
      dbms_session.clear_all_context(
         namespace => g_context_name);
    $end

    COMMIT;
  END null_global_contexts;


  /**
   * Converts string names to text value
   *
   * Changes
   *  - 2.1.0: Start to use global variables and correct numbers
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level String representation of level
   * @return level number. -1 if not found
   */
  FUNCTION convert_level_char_to_num(p_level IN VARCHAR2)
    RETURN NUMBER
  IS
    l_level NUMBER;
  BEGIN
    $if $$no_op $then
      return null;
    $else
      case p_level
        when g_off_name then l_level := g_off;
        when g_permanent_name then l_level := g_permanent;
        when g_error_name then l_level := g_error;
        when g_warning_name then l_level := g_warning;
        when g_information_name then l_level := g_information;
        when g_debug_name then l_level := g_debug;
        when g_timing_name then l_level := g_timing;
        when g_sys_context_name then l_level := g_sys_context;
        when g_apex_name then l_level := g_apex;
        else l_level := -1;
      end case;
    $end

    RETURN l_level;
  END convert_level_char_to_num;


  /**
   * Converts the logger level num to char format
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_level
   * @return Logger level string format
   */
  FUNCTION convert_level_num_to_char(p_level IN NUMBER)
    RETURN VARCHAR2
  IS
    l_return VARCHAR2(255);
  BEGIN
    $if $$no_op $then
      null;
    $else
      l_return :=
        case p_level
          when g_off then g_off_name
          when g_permanent then g_permanent_name
          when g_error then g_error_name
          when g_warning then g_warning_name
          when g_information then g_information_name
          when g_debug then g_debug_name
          when g_timing then g_timing_name
          when g_sys_context then g_sys_context_name
          when g_apex then g_apex_name
          else null
        end;
    $end

    RETURN l_return;
  END convert_level_num_to_char;





  /**
   * Determines if the statement can be stored in LOGGER_LOGS
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #44: Expose publically
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Level (number)
   * @return True of statement can be logged to LOGGER_LOGS
   */
  FUNCTION ok_to_log(p_level IN NUMBER)
    RETURN BOOLEAN
  $if 1=1
    and $$rac_lt_11_2
    and not dbms_db_version.ver_le_10_2
    and ($$no_op is null or not $$no_op) $then
      result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
  $end
  IS
    l_level      NUMBER;
    l_level_char VARCHAR2(50);

  $if $$logger_debug $then
    l_scope varchar2(30) := 'ok_to_log';
  $end

  BEGIN
  $if $$no_op $then
    return false;
  $else

    $if $$logger_debug $then
      dbms_output.put_line(l_scope || ': in function');
    $end

    $if $$rac_lt_11_2 $then
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ': calling get_level_number');
      $end
      l_level := get_level_number;
    $else
      l_level := sys_context(g_context_name,gc_ctx_attr_level);

      if l_level is null then
        $if $$logger_debug $then
          dbms_output.put_line(l_scope || ': level was null, getting and setting in context');
        $end

        l_level := get_level_number;

        save_global_context(
          p_attribute => gc_ctx_attr_level,
          p_value => l_level,
          p_client_id => sys_context('userenv','client_identifier'));
      end if;
    $end

    if l_level >= p_level then
      return true;
    else
      return false;
    end if;
 $end
  END ok_to_log;


  /**
   * Determines if log statements will actually be stored.
   *
   * @author Martin D'Souza
   * @created 25-Jul-2013
   *
   * @param p_level Level (DEBUG etc..)
   * @return True of log statements for that level or below will be logged
   */
  FUNCTION ok_to_log(p_level IN VARCHAR2)
    RETURN BOOLEAN
  AS
  BEGIN
  $if $$no_op $then
    return false;
  $else
    return ok_to_log(p_level => convert_level_char_to_num(p_level => p_level));
  $end
  END ok_to_log;




  /**
   * ???
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date
   * @return
   */
  FUNCTION date_text_format(p_date IN DATE)
    RETURN VARCHAR2
  AS
  BEGIN
  $if $$no_op $then
    return null;
  $else
    return date_text_format_base(
      p_date_start => p_date   ,
      p_date_stop  => sysdate);
  $end
  END date_text_format;


  FUNCTION get_character_codes(p_string            IN VARCHAR2,
                               p_show_common_codes IN BOOLEAN DEFAULT TRUE)
    RETURN VARCHAR2
  IS
    l_string VARCHAR2(32767);
    l_dump   VARCHAR2(32767);
    l_return VARCHAR2(32767);
  BEGIN
    -- replace tabs with ^
    l_string := REPLACE(p_string, CHR(9), '^');
    -- replace all other control characters such as carriage return / line feeds with ~
    l_string := REGEXP_REPLACE(l_string, '[[:cntrl:]]', '~', 1, 0, 'm');

    SELECT DUMP(p_string)
      INTO l_dump
      FROM dual;

    l_dump := REGEXP_REPLACE(l_dump, '(^.+?:)(.*)', '\2', 1, 0); -- get everything after the :
    l_dump := ',' || l_dump || ','; -- leading and trailing commas
    l_dump := REPLACE(l_dump, ',', ',,'); -- double the commas. this is for the regex.
    l_dump := REGEXP_REPLACE(l_dump, '(,)([[:digit:]]{1})(,)', '\1  \2\3', 1, 0); -- lpad all single digit numbers out to 3
    l_dump := REGEXP_REPLACE(l_dump, '(,)([[:digit:]]{2})(,)', '\1 \2\3', 1, 0);  -- lpad all double digit numbers out to 3
    l_dump := LTRIM(REPLACE(l_dump, ',,', ','), ','); -- remove the double commas
    l_dump := LPAD(' ', (5 - INSTR(l_dump, ',')), ' ') || l_dump;

    -- replace every individual character with 2 spaces, itself and a comma so it lines up with the dump output
    l_string := ' ' || REGEXP_REPLACE(l_string, '(.){1}', '  \1,', 1, 0);

    l_return := RTRIM(l_dump, ',') || CHR(10) || RTRIM(l_string, ',');

    IF p_show_common_codes
    THEN
      l_return := 'Common Codes: 13=Line Feed, 10=Carriage Return, 32=Space, 9=Tab' || CHR(10) || l_return;
    END IF;

    RETURN l_return;

  END get_character_codes;

  /**
   * Store APEX items in logger_logs_apex_items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115: Only log not-null values
   *  - #114: Bulk insert (no more row by row)
   *  - #54: Support for p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_log_id logger_logs.id to reference
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page. It is assumed that it has been validated by the time it hits here.
   * @param p_log_null_items If set to false, null values won't be logged
   */
  PROCEDURE snapshot_apex_items(p_log_id         IN logger_logs.id % TYPE,
                                p_item_type      IN VARCHAR2,
                                p_log_null_items IN BOOLEAN)
  IS
    l_app_session       NUMBER;
    l_app_id            NUMBER;
    l_log_null_item_yn  VARCHAR2(1);
    l_item_type         VARCHAR2(30) := UPPER(p_item_type);
    l_item_type_page_id NUMBER;
  BEGIN
    $if $$no_op $then
      null;
    $else
      $if $$apex $then
        l_app_session := v('APP_SESSION');
        l_app_id := v('APP_ID');

        l_log_null_item_yn := 'N';
        if p_log_null_items then
          l_log_null_item_yn := 'Y';
        end if;

        if logger.is_number(l_item_type) then
          l_item_type_page_id := to_number(l_item_type);
        end if;

        insert into logger_logs_apex_items(log_id,app_session,item_name,item_value)
        select p_log_id, l_app_session, item_name, item_value
        from (
          -- Application items
          select 1 app_page_seq, 0 page_id, item_name, v(item_name) item_value
          from apex_application_items
          where 1=1
            and application_id = l_app_id
            and l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_app)
          union all
          -- Application page items
          select 2 app_page_seq, page_id, item_name, v(item_name) item_value
          from apex_application_page_items
          where 1=1
            and application_id = l_app_id
            and (
              1=2
              or l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_page)
              or (l_item_type_page_id is not null and l_item_type_page_id = page_id)
            )
          )
        where 1=1
          and (l_log_null_item_yn = 'Y' or item_value is not null)
        order by app_page_seq, page_id, item_name;

      $end -- $if $$apex $then

      null; -- Keep this in place incase APEX is not compiled
    $end -- $$no_op
  end snapshot_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #46: Added plugin support
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_error(
    p_text in varchar2 default null,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
    l_proc_name varchar2(100);
    l_lineno varchar2(100);
    l_text varchar2(32767);
    l_call_stack varchar2(4000);
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_error) then
        get_debug_info(
          p_callstack => dbms_utility.format_call_stack,
          o_unit => l_proc_name,
          o_lineno => l_lineno);

        l_call_stack := dbms_utility.format_error_stack() || gc_line_feed || dbms_utility.format_error_backtrace;

        if p_text is not null then
          l_text := p_text || gc_line_feed || gc_line_feed;
        end if;

        l_text := l_text || dbms_utility.format_error_stack();

        l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

        ins_logger_logs(
          p_unit_name => upper(l_proc_name) ,
          p_scope => p_scope ,
          p_logger_level => logger.g_error,
          p_extra => l_extra,
          p_text => l_text,
          p_call_stack => l_call_stack,
          p_line_no => l_lineno,
          po_id => g_log_id);

        -- Plugin
        $if $$logger_plugin_error $then

          if not g_in_plugin_error then
            g_plug_logger_log_error.logger_level := logger.g_error;
            g_plug_logger_log_error.id := g_log_id;

            $if $$logger_debug $then
              dbms_output.put_line('Starting call to run_plugin error');
            $end

            run_plugin(p_logger_log => g_plug_logger_log_error);
          end if; -- not g_in_plugin_error
        $end

      end if; -- ok_to_log
    $end
  end log_error;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_permanent(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_permanent) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_permanent,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params
        );
      end if;
    $end
  end log_permanent;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warning(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_warning) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_warning,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_warning;


  /**
   * Wrapper for log_warning
   *
   * Notes:
   *  - #80
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 9-9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warn(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_warning(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_warn;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_information(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_information) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_information,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_information;


  /**
   * Wrapper for short call to log_information
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #80
   *
   * @author Martin D'Souza
   * @created 9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_info(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_information(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_info;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin

    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_debug,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log;


  /**
   * Get list of CGI values
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @return CGI values
   */
  function get_cgi_env(
    p_show_null   in boolean default false)
    return clob
  is
    l_cgienv clob;

    $if $$no_op is null or not $$no_op $then
      procedure append_cgi_env(
        p_name    in varchar2,
        p_val   in varchar2)
      is
        r_pad number := 30;
      begin
        if p_show_null or p_val is not null then
          l_cgienv := l_cgienv || rpad(p_name,r_pad,' ')||': '||p_val||gc_cflf;
        end if;
      end append_cgi_env;
    $end

  begin
    $if $$no_op $then
      return null;
    $else
      for i in 1..nvl(owa.num_cgi_vars,0) loop
        append_cgi_env(
          p_name      => owa.cgi_var_name(i),
          p_val       => owa.cgi_var_val(i));

      end loop;

      return l_cgienv;
    $end
  end get_cgi_env;


  /**
   * Logs system environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   * - #29 Support for definging level
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, INSTANCE
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_userenv(
    p_detail_level in varchar2 default 'USER',-- ALL, NLS, USER, INSTANCE,
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_sys_context(
          p_detail_level => p_detail_level,
          p_vertical => true,
          p_show_null => p_show_null);

        log_internal(
          p_text => 'USERENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_userenv;


  /**
   * Logs CGI environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_cgi_env(
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_cgi_env(p_show_null    => p_show_null);
        log_internal(
          p_text => 'CGI ENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_cgi_env;


  /**
   * Logs character codes for given string
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_show_common_codes
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_character_codes(
    p_text in varchar2,
    p_scope in logger_logs.scope%type default null,
    p_show_common_codes in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    l_dump clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_dump := get_character_codes(p_text,p_show_common_codes);

        log_internal(
          p_text => 'GET_CHARACTER_CODES output stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_debug),
          p_scope => p_scope,
          p_extra => l_dump);
      end if;
    $end
  end log_character_codes;


  /**
   * Log's APEX items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115 Only log not-null values
   *  - #29 Support for definging level
   *  - #54: Add p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page.
   * @param p_log_null_items If set to false, null values won't be logged
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_apex_items(
    p_text in varchar2 default 'Log APEX Items',
    p_scope in logger_logs.scope%type default null,
    p_item_type in varchar2 default logger.g_apex_item_type_all,
    p_log_null_items in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then

        $if $$apex $then
          -- Validate p_item_type
          assert(
            p_condition => upper(p_item_type) in (logger.g_apex_item_type_all, logger.g_apex_item_type_app, logger.g_apex_item_type_page) or logger.is_number(p_item_type),
            p_message => logger.sprintf('APEX Item Scope was set to %s. Must be %s, %s, %s, or page number', p_item_type, logger.g_apex_item_type_all, logger.g_apex_item_type_page, logger.g_apex_item_type_page));

          log_internal(
            p_text => p_text,
            p_log_level => nvl(p_level, logger.g_apex),
            p_scope => p_scope);

          snapshot_apex_items(
            p_log_id => g_log_id,
            p_item_type => upper(p_item_type),
            p_log_null_items => p_log_null_items);
        $else
          l_error := 'Error! Logger is not configured for APEX yet. ';

          log_internal(
            p_text => l_error,
            p_log_level => logger.g_apex,
            p_scope => p_scope);
        $end
      end if;
    $end
    commit;
  end log_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Use localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_log_in_table
   */
  procedure time_start(
    p_unit in varchar2,
    p_log_in_table in boolean default true)
  is
    l_proc_name varchar2(100);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := g_running_timers + 1;

        if g_running_timers > 1 then
          -- Use 'a' since lpad requires a value to pad
          l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
        end if;

        g_proc_start_times(p_unit) := localtimestamp;

        l_text := l_pad||'START: '||p_unit;

        if p_log_in_table then
          ins_logger_logs(
            p_unit_name => p_unit ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_start;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73: Remove additional timer decrement since it was already happening in function time_stop
   *
   * @author Tyler Muth
   * @created ???
   * @param p_scope
   * @param p_unit
   */
  procedure time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null)
  is
    l_time_string varchar2(50);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          if g_running_timers > 1 then
            -- Use 'a' since lpad requires a value to pad
            l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
          end if;

          --l_time_string := rtrim(regexp_replace(systimestamp-(g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);
          -- Function time_stop will decrement the timers and pop the name from the g_proc_start_times array
          l_time_string := time_stop(
            p_unit => p_unit,
            p_log_in_table => false);

          l_text := l_pad||'STOP : '||p_unit ||' - '||l_time_string;

          ins_logger_logs(
            p_unit_name => p_unit,
            p_scope => p_scope ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer string
   */
  function time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table IN boolean default true)
    return varchar2
  is
    l_time_string varchar2(50);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          l_time_string := rtrim(regexp_replace(localtimestamp - (g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_time_string,
              po_id => g_log_id);
          end if;

          return l_time_string;

        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer in seconds
   */
  function time_stop_seconds(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true
    )
    return number
  is
    l_time_string varchar2(50);
    l_seconds number;
    l_interval interval day to second;

  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then
          l_interval := localtimestamp - (g_proc_start_times(p_unit));
          l_seconds := extract(day from l_interval) * 86400 + extract(hour from l_interval) * 3600 + extract(minute from l_interval) * 60 + extract(second from l_interval);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_seconds,
              po_id => g_log_id);
          end if;

          return l_seconds;

        end if;
      end if;
    $end
  end time_stop_seconds;


  /**
   * Resets all timers
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure time_reset
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := 0;
        g_proc_start_times.delete;
      end if;
    $end
  end time_reset;

  /**
   * Returns Global or User preference
   * User preference is only valid for LEVEL and INCLUDE_CALL_STACK
   *  - If a user setting exists, it will be returned, if not the system level preference will be return
   *
   * Updates
   *  - 2.0.0: Added user preference support
   *  - 2.1.2: Fixed issue when calling set_level with the same client_id multiple times
   *
   * Related Tickets:
   *  - #127: Added logger_prefs.pref_type
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_pref_name
   * @param p_pref_type Namespace for preference
   */
  function get_pref(
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_type in logger_prefs.pref_type%type default logger.g_pref_type_logger)
    return varchar2
    $if not dbms_db_version.ver_le_10_2  $then
      result_cache
      $if $$no_op is null or not $$no_op $then
        relies_on (logger_prefs, logger_prefs_by_client_id)
      $end
    $end
  is
    l_scope varchar2(30) := 'get_pref';
    l_pref_value logger_prefs.pref_value%type;
    l_client_id logger_prefs_by_client_id.client_id%type;
    l_pref_name logger_prefs.pref_name%type := upper(p_pref_name);
    l_pref_type logger_prefs.pref_type%type := upper(p_pref_type);
  begin

    $if $$no_op $then
      return null;
    $else
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ' select pref');
      $end

      l_client_id := sys_context('userenv','client_identifier');

      select pref_value
      into l_pref_value
      from (
        select pref_value, row_number () over (order by rank) rn
        from (
          -- Client specific logger levels trump system level logger level
          select
            case
              when l_pref_name = logger.gc_pref_level then logger_level
              when l_pref_name = logger.gc_pref_include_call_stack then include_call_stack
            end pref_value,
            1 rank
          from logger_prefs_by_client_id
          where 1=1
            and client_id = l_client_id
            -- Only try to get prefs at a client level if pref is in LEVEL or INCLUDE_CALL_STACK
            and l_client_id is not null
            -- #127
            -- Prefs by client aren't available for custom prefs right now
            -- Only need to search this table if p_pref_type is LOGGER
            and l_pref_type = logger.g_pref_type_logger
            and l_pref_name in (logger.gc_pref_level, logger.gc_pref_include_call_stack)
          union
          -- System level configuration
          select pref_value, 2 rank
          from logger_prefs
          where 1=1
            and pref_name = l_pref_name
            and pref_type = l_pref_type
        )
      )
      where rn = 1;
      return l_pref_value;
    $end

  exception
    when no_data_found then
      return null;
    when others then
      raise;
  end get_pref;


  /**
   * Sets a preference
   * If it does not exist, it will insert one
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 24-APR-2015
   * @param p_pref_type
   * @param p_pref_name
   * @param p_pref_value
   */
  procedure set_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_value in logger_prefs.pref_value%type)
  as
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper(p_pref_name));
  begin

    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not set ' || l_pref_type || '. Reserved for Logger');
      end if;

      merge into logger_prefs p
      using (select l_pref_type pref_type, l_pref_name pref_name, p_pref_value pref_value
             from dual) args
      on ( 1=1
        and p.pref_type = args.pref_type
        and p.pref_name = args.pref_name)
      when matched then
        update
        set p.pref_value =  args.pref_value
      when not matched then
        insert (pref_type, pref_name ,pref_value)
      values
        (args.pref_type, args.pref_name ,args.pref_value);
    $end -- $no_op

  end set_pref;

  /**
   * Removes a Preference
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 30-APR-2015
   *
   * @param p_pref_type
   * @param p_pref_name
   */
  procedure del_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type)
  is
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper (p_pref_name));
  begin
    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not delete ' || l_pref_type || '. Reserved for Logger');
      end if;

      delete from logger_prefs
      where 1=1
        and pref_type = l_pref_type
        and pref_name = l_pref_name;
    $end
  end del_pref;


  /**
   * Purges logger_logs data
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48 Support for overloading
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in number default null,
    p_purge_min_level in number)

  is
    $if $$no_op is null or not $$no_op $then
      l_purge_after_days number := nvl(p_purge_after_days,get_pref(logger.gc_pref_purge_after_days));
    $end
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else

      if admin_security_check then
        delete
          from logger_logs
         where logger_level >= p_purge_min_level
           and time_stamp < systimestamp - NUMTODSINTERVAL(l_purge_after_days, 'day')
           and logger_level > g_permanent;
      end if;
    $end
    commit;
  end purge;


  /**
   * Wrapper for Purge (to accept number for purge_min_level)
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in varchar2 default null,
    p_purge_min_level in varchar2 default null)

  is
  begin
    $if $$no_op $then
      null;
    $else
      purge(
        p_purge_after_days => to_number(p_purge_after_days),
        p_purge_min_level => convert_level_char_to_num(nvl(p_purge_min_level,get_pref(logger.gc_pref_purge_min_level))));
    $end
  end purge;


  /**
   * Purges all records that aren't marked as permanent
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure purge_all
  is
    l_purge_level number  := g_permanent;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if admin_security_check then
        delete from logger_logs where logger_level > l_purge_level;
      end if;
    $end
    commit;
  end purge_all;


  /**
   * Displays Logger's current status
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_output_format SQL-DEVELOPER | HTML | DBMS_OUPUT
   */
  procedure status(
    p_output_format in varchar2 default null) -- SQL-DEVELOPER | HTML | DBMS_OUPUT
  is
    l_debug varchar2(50) := 'Disabled';
    l_apex varchar2(50) := 'Disabled';
    l_flashback varchar2(50) := 'Disabled';
    dummy varchar2(255);
    l_output_format varchar2(30);
    l_version varchar2(20);
    l_client_identifier logger_prefs_by_client_id.client_id%type;

    -- For current client info
    l_cur_logger_level logger_prefs_by_client_id.logger_level%type;
    l_cur_include_call_stack logger_prefs_by_client_id.include_call_stack%type;
    l_cur_expiry_date logger_prefs_by_client_id.expiry_date%type;

    procedure display_output(
      p_name  in varchar2,
      p_value in varchar2)
    is
    begin
      if l_output_format = 'SQL-DEVELOPER' then
        dbms_output.put_line('<pre>'||rpad(p_name,25)||': <strong>'||p_value||'</strong></pre>');
      elsif l_output_format = 'HTTP' then
        htp.p('<br />'||p_name||': <strong>'||p_value||'</strong>');
      else
        dbms_output.put_line(rpad(p_name,25)||': '||p_value);
      end if;
    end display_output;

  begin
    if p_output_format is null then
      begin
        dummy := owa_util.get_cgi_env('HTTP_HOST');
        l_output_format := 'HTTP';
      exception
        when value_error then
        l_output_format := 'DBMS_OUTPUT';
        dbms_output.enable;
      end;
    else
      l_output_format := p_output_format;
    end if;

    display_output('Project Home Page','https://github.com/oraopensource/logger/');

    $if $$no_op $then
      display_output('Debug Level','NO-OP, Logger completely disabled.');
    $else
      $if $$apex $then
        l_apex := 'Enabled';
      $end

      select pref_value
      into l_debug
      from logger_prefs
      where 1=1
        and pref_type = logger.g_pref_type_logger
        and pref_name = logger.gc_pref_level;

      $if $$flashback_enabled $then
        l_flashback := 'Enabled';
      $end

      l_version := get_pref(logger.gc_pref_logger_version);

      display_output('Logger Version',l_version);
      display_output('Debug Level',l_debug);
      display_output('Capture Call Stack',get_pref(logger.gc_pref_include_call_stack));
      display_output('Protect Admin Procedures',get_pref(logger.gc_pref_protect_admin_procs));
      display_output('APEX Tracing',l_apex);
      display_output('SCN Capture',l_flashback);
      display_output('Min. Purge Level',get_pref(logger.gc_pref_purge_min_level));
      display_output('Purge Older Than',get_pref(logger.gc_pref_purge_after_days)||' days');
      display_output('Pref by client_id expire hours',get_pref(logger.gc_pref_client_id_expire_hours)||' hours');
      $if $$rac_lt_11_2  $then
        display_output('RAC pre-11.2 Code','TRUE');
      $end

      -- #46 Only display plugins if enabled
      $if $$logger_plugin_error $then
        display_output('PLUGIN_FN_ERROR',get_pref(logger.gc_pref_plugin_fn_error));
      $end

      -- #64
      $if $$logger_debug $then
        display_output('LOGGER_DEBUG',get_pref(logger.gc_pref_logger_debug) || '   *** SHOULD BE TURNED OFF!!! SET TO FALSE ***');
      $end


      l_client_identifier := sys_context('userenv','client_identifier');
      if l_client_identifier is not null then
        -- Since the client_identifier exists, try to see if there exists a record session sepecfic logging level
        -- Note: this query should only return 0..1 rows
        begin
          select logger_level, include_call_stack, expiry_date
          into l_cur_logger_level, l_cur_include_call_stack, l_cur_expiry_date
          from logger_prefs_by_client_id
          where client_id = l_client_identifier;

          display_output('Client Identifier', l_client_identifier);
          display_output('Client - Debug Level', l_cur_logger_level);
          display_output('Client - Call Stack', l_cur_include_call_stack);
          display_output('Client - Expiry Date', logger.tochar(l_cur_expiry_date));
        exception
          when no_data_found then
            null; -- No client specific logging set
          when others then
            raise;
        end;
      end if; -- client_identifier exists

      display_output('For all client info see', 'logger_prefs_by_client_id');

    $end
  end status;


  /**
   * Sets the logger level
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #60 Allow security check to be bypassed for client specific logging level
   *  - #48 Allow of numbers to be passed in p_level. Did not overload (see ticket comments as to why)
   *  - #110 Clear context values when level changes globally
   *  - #29 If p_level is deprecated, set to DEBUG
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Valid values: OFF,PERMANENT,ERROR,WARNING,INFORMATION,DEBUG,TIMING
   * @param p_client_id Optional: If defined, will set the level for the given client identifier. If null will affect global settings
   * @param p_include_call_stack Optional: Only valid if p_client_id is defined Valid values: TRUE, FALSE. If not set will use the default system pref in logger_prefs.
   * @param p_client_id_expire_hours If p_client_id, expire after number of hours. If not defined, will default to system preference PREF_BY_CLIENT_ID_EXPIRE_HOURS
   */
  procedure set_level(
    p_level in varchar2 default logger.g_debug_name,
    p_client_id in varchar2 default null,
    p_include_call_stack in varchar2 default null,
    p_client_id_expire_hours in number default null
  )
  is
    l_level varchar2(20);
    l_ctx varchar2(2000);
    l_include_call_stack varchar2(255);
    l_client_id_expire_hours number;
    l_expiry_date logger_prefs_by_client_id.expiry_date%type;

    l_id logger_logs.id%type;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      raise_application_error (-20000,
          'Either the NO-OP version of Logger is installed or it is compiled for NO-OP,  so you cannot set the level.');
    $else
      l_level := replace(upper(p_level),' ');

      if is_number(p_str => l_level) then
        l_level := convert_level_num_to_char(p_level => p_level);
      end if;

      l_include_call_stack := nvl(trim(upper(p_include_call_stack)), get_pref(logger.gc_pref_include_call_stack));

      assert(
          l_level in (g_off_name, g_permanent_name, g_error_name, g_warning_name, g_information_name, g_debug_name, g_timing_name, g_sys_context_name, g_apex_name),
        '"LEVEL" must be one of the following values: ' ||
          g_off_name || ', ' || g_permanent_name || ', ' || g_error_name || ', ' || g_warning_name || ', ' ||
          g_information_name || ', ' || g_debug_name || ', ' || g_timing_name || ', ' ||
          g_sys_context_name || ', ' || g_apex_name );
      assert(l_include_call_stack in ('TRUE', 'FALSE'), 'l_include_call_stack must be TRUE or FALSE');

      -- #60 Allow security check to be bypassed for client specific logging level
      if p_client_id is not null or admin_security_check then
        l_ctx := 'Host: '||sys_context('USERENV','HOST');
        l_ctx := l_ctx || ', IP: '||sys_context('USERENV','IP_ADDRESS');
        l_ctx := l_ctx || ', TERMINAL: '||sys_context('USERENV','TERMINAL');
        l_ctx := l_ctx || ', OS_USER: '||sys_context('USERENV','OS_USER');
        l_ctx := l_ctx || ', CURRENT_USER: '||sys_context('USERENV','CURRENT_USER');
        l_ctx := l_ctx || ', SESSION_USER: '||sys_context('USERENV','SESSION_USER');

        -- #29 Deprecate old levels. Log and set to DEBUG
        if l_level in (logger.g_apex_name, logger.g_sys_context_name, logger.g_timing_name)  then
          logger.ins_logger_logs(
            p_logger_level => logger.g_warning,
            p_text =>
              logger.sprintf('Logger level: %s1 is deprecated. Set for client_id %s2. Automatically setting to %s3', l_level, nvl(p_client_id, '<global>'), logger.g_debug_name),
            po_id => l_id);

          l_level := logger.g_debug_name;
        end if;


        -- Separate updates/inserts for client_id or global settings
        if p_client_id is not null then
          l_client_id_expire_hours := nvl(p_client_id_expire_hours, get_pref(logger.gc_pref_client_id_expire_hours));
          l_expiry_date := sysdate + l_client_id_expire_hours/24;

          merge into logger_prefs_by_client_id ci
          using (select p_client_id client_id from dual) s
            on (ci.client_id = s.client_id)
          when matched then update
            set logger_level = l_level,
              include_call_stack = l_include_call_stack,
              expiry_date = l_expiry_date,
              created_date = sysdate
          when not matched then
            insert(ci.client_id, ci.logger_level, ci.include_call_stack, ci.created_date, ci.expiry_date)
            values(p_client_id, l_level, l_include_call_stack, sysdate, l_expiry_date)
          ;

        else
          -- Global settings
          update logger_prefs
          set pref_value = l_level
          where 1=1
            and pref_type = logger.g_pref_type_logger
            and pref_name = logger.gc_pref_level;
        end if;

        -- #110 Need to reset all contexts so that level is reset for sessions where client_identifier is defined
        -- This is required for global changes since sessions with client_identifier set won't be properly updated.
        if p_client_id is null then
          logger.null_global_contexts;
        end if;

        logger.save_global_context(
          p_attribute => gc_ctx_attr_level,
          p_value => logger.convert_level_char_to_num(l_level),
          p_client_id => p_client_id); -- Note: if p_client_id is null then it will set for global`

        -- Manual insert to ensure that data gets logged, regardless of logger_level
        logger.ins_logger_logs(
          p_logger_level => logger.g_information,
          p_text => 'Log level set to ' || l_level || ' for client_id: ' || nvl(p_client_id, '<global>') || ', include_call_stack=' || l_include_call_stack || ' by ' || l_ctx,
          po_id => l_id);

      end if; -- p_client_id is not null or admin_security_check
    $end
    commit;
  end set_level;


  /**
   * Unsets a logger level for a given client_id
   * This will only unset for client specific logger levels
   * Note: An explicit commit will occur in this procedure
   *
   * @author Martin D'Souza
   * @created 6-Apr-2013
   *
   * @param p_client_id Client identifier (case sensitive) to unset logger level in.
   */
  procedure unset_client_level(p_client_id in varchar2)
  as
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      assert(p_client_id is not null, 'p_client_id is a required value');

      -- Remove from client specific table
      delete from logger_prefs_by_client_id
      where client_id = p_client_id;

      -- Remove context values
      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_level);

      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_include_call_stack);

    $end

    commit;
  end unset_client_level;


  /**
   * Unsets client_level that are stale (i.e. past thier expiry date)
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   * @param p_unset_after_hours If null then preference UNSET_CLIENT_ID_LEVEL_AFTER_HOURS
   */
  procedure unset_client_level
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (
        select client_id
        from logger_prefs_by_client_id
        where sysdate > expiry_date) loop

        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level;


  /**
   * Unsets all client specific preferences
   * An implicit commit will occur as unset_client_level makes a commit
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   */
  procedure unset_client_level_all
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (select client_id from logger_prefs_by_client_id) loop
        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level_all;


  /**
   * Displays commonly used dbms_output SQL*Plus settings
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure sqlplus_format
  is
  begin
    execute immediate 'begin dbms_output.enable(1000000); end;';
    dbms_output.put_line('set linesize 200');
    dbms_output.put_line('set pagesize 100');

    dbms_output.put_line('column id format 999999');
    dbms_output.put_line('column text format a75');
    dbms_output.put_line('column call_stack format a100');
    dbms_output.put_line('column extra format a100');

  end sqlplus_format;

  /**
   * Converts parameter to varchar2
   *
   * Notes:
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *  - Need to call this tochar instead of to_char since there will be a conflict when calling it
   *
   * Related Tickets:
   *  - #68
   *
   * @author Martin D'Souza
   * @created 07-Jun-2014
   * @param p_value
   * @return varchar2 value for p_value
   */
  function tochar(
    p_val in number)
    return varchar2
  as
  begin
    return to_char(p_val);
  end tochar;

  function tochar(
    p_val in date)
    return varchar2
  as
  begin
    return to_char(p_val, gc_date_format);
  end tochar;

  function tochar(
    p_val in timestamp)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_format);
  end tochar;

  function tochar(
    p_val in timestamp with time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  function tochar(
    p_val in timestamp with local time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  -- #119: Return null for null booleans
  function tochar(
    p_val in boolean)
    return varchar2
  as
  begin
    return case p_val when true then 'TRUE' when false then 'FALSE' else null end;
  end tochar;



  -- Handle Parameters

  /**
   * Append parameter to table of parameters
   * Nothing is actually logged in this procedure
   * This procedure is overloaded
   *
   * Related Tickets:
   *  - #67: Updated to reference to_char functions
   *
   * @author Martin D'Souza
   * @created 19-Jan-2013
   *
   * @param p_params Table of parameters (param will be appended to this)
   * @param p_name Name
   * @param p_val Value in its format. Will be converted to string
   */
  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in varchar2
  )
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      l_param.name := p_name;
      l_param.val := p_val;
      p_params(p_params.count + 1) := l_param;
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in number)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in date)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with local time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in boolean)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;


  /**
   * Handles inserts into LOGGER_LOGS.
   *
   * Replaces trigger for both performance issues and to be a single location for all insert statements
   *
   * autonomous_transaction so commit will be performed after insert
   *
   * @author Martin D'Souza
   * @created 30-Jul-2013
   *
   * Related Issues
   *  - #31: Initial ticket
   *  - #51: Added SID column
   *  - #70: Fixed missing no_op flag
   *  - #109: Fix length check for multibyte characters
   *
   * @param p_logger_level
   * @param p_text
   * @param p_scope
   * @param p_call_stack
   * @param p_unit_name
   * @param p_line_no
   * @param p_extra
   * @param po_id ID entered into logger_logs for this record
   */
  procedure ins_logger_logs(
    p_logger_level in logger_logs.logger_level%type,
    p_text in varchar2 default null, -- Not using type since want to be able to pass in 32767 characters
    p_scope in logger_logs.scope%type default null,
    p_call_stack in logger_logs.call_stack%type default null,
    p_unit_name in logger_logs.unit_name%type default null,
    p_line_no in logger_logs.line_no%type default null,
    p_extra in logger_logs.extra%type default null,
    po_id out nocopy logger_logs.id%type
    )
  as
    pragma autonomous_transaction;

    l_id logger_logs.id%type;
    l_text varchar2(32767) := p_text;
    l_extra logger_logs.extra%type := p_extra;
    l_tmp_clob clob;

  begin
    $if $$no_op $then
      null;
    $else
      -- Using select into to support version older than 11gR1 (see Issue 26)
      select logger_logs_seq.nextval
      into po_id
      from dual;

      -- 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column (Issue 17)
      $if $$large_text_column $then -- Only check for moving to Clob if small text column
        -- Don't do anything since column supports large text
      $else
        if lengthb(l_text) > 4000 then -- #109 Using lengthb for multibyte characters
          if l_extra is null then
            l_extra := l_text;
          else
            -- Using temp clob for performance purposes: http://www.talkapex.com/2009/06/how-to-quickly-append-varchar2-to-clob.html
            l_tmp_clob := gc_line_feed || gc_line_feed || '*** Content moved from TEXT column ***' || gc_line_feed;
            l_extra := l_extra || l_tmp_clob;
            l_tmp_clob := l_text;
            l_extra := l_extra || l_text;
          end if; -- l_extra is not null

          l_text := 'Text moved to EXTRA column';
        end if; -- length(l_text)
      $end

      insert into logger_logs(
        id, logger_level, text,
        time_stamp, scope, module,
        action,
        user_name,
        client_identifier,
        call_stack, unit_name, line_no ,
        scn,
        extra,
        sid,
        client_info
        )
       values(
         po_id, p_logger_level, l_text,
         systimestamp, lower(p_scope), sys_context('userenv','module'),
         sys_context('userenv','action'),
         nvl($if $$apex $then apex_application.g_user $else user $end,user),
         sys_context('userenv','client_identifier'),
         p_call_stack, upper(p_unit_name), p_line_no,
         null,
         l_extra,
         to_number(sys_context('userenv','sid')),
         sys_context('userenv','client_info')
         );

    $end -- $$NO_OP

    commit;
  end ins_logger_logs;


  /**
   * Does string replacement similar to C's sprintf
   *
   * Notes:
   *  - Uses the following replacement algorithm (in following order)
   *    - Replaces %s<n> with p_s<n>
   *    - Occurrences of %s (no number) are replaced with p_s1..p_s10 in order that they appear in text
   *    - %% is escaped to %
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *
   * Related Tickets:
   *  - #32: Also see #59
   *  - #95: Remove no_op clause
   *
   * @author Martin D'Souza
   * @created 15-Jun-2014
   * @param p_str Messsage to format using %s and %d replacement strings
   * @param p_s1
   * @param p_s2
   * @param p_s3
   * @param p_s4
   * @param p_s5
   * @param p_s6
   * @param p_s7
   * @param p_s8
   * @param p_s9
   * @param p_s10
   * @return p_msg with strings replaced
   */
  function sprintf(
    p_str in varchar2,
    p_s1 in varchar2 default null,
    p_s2 in varchar2 default null,
    p_s3 in varchar2 default null,
    p_s4 in varchar2 default null,
    p_s5 in varchar2 default null,
    p_s6 in varchar2 default null,
    p_s7 in varchar2 default null,
    p_s8 in varchar2 default null,
    p_s9 in varchar2 default null,
    p_s10 in varchar2 default null)
    return varchar2
  as
    l_return varchar2(4000);
    c_substring_regexp constant varchar2(10) := '%s';

  begin
    l_return := p_str;

    -- Replace %s<n> with p_s<n>``
    for i in 1..10 loop
      l_return := regexp_replace(l_return, c_substring_regexp || i,
        case
          when i = 1 then p_s1
          when i = 2 then p_s2
          when i = 3 then p_s3
          when i = 4 then p_s4
          when i = 5 then p_s5
          when i = 6 then p_s6
          when i = 7 then p_s7
          when i = 8 then p_s8
          when i = 9 then p_s9
          when i = 10 then p_s10
          else null
        end,
        1,0,'c');
    end loop;

    $if $$logger_debug $then
      dbms_output.put_line('Before sys.utl_lms: ' || l_return);
    $end

    -- Replace any occurences of %s with p_s<n> (in order) and escape %% to %
    l_return := sys.utl_lms.format_message(l_return,p_s1, p_s2, p_s3, p_s4, p_s5, p_s6, p_s7, p_s8, p_s9, p_s10);

    return l_return;

  end sprintf;


  /**
   * Returns the rec_logger_logs for given logger_level
   * Used for plugin.
   * Not meant to be called by general public, and thus not documented
   *
   * Notes:
   *  - -- FUTURE mdsouza: Add tests for this (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_level Logger level of plugin wanted to return
   * @return Logger rec based on plugin type
   */
  function get_plugin_rec(
    p_logger_level in logger_logs.logger_level%type)
    return logger.rec_logger_log
  as
  begin

    if p_logger_level = logger.g_error then
      return g_plug_logger_log_error;
    end if;
  end get_plugin_rec;

end logger;
/

--
-- Definition for package TEPLSQL
--
CREATE OR REPLACE PACKAGE teplsql
  AS
  --Define Associative Array
  TYPE t_assoc_array IS TABLE OF VARCHAR2(32767)
    INDEX BY VARCHAR2 (255);

  null_assoc_array t_assoc_array;

  /**
  * Output CLOB data to the DBMS_OUTPUT.PUT_LINE
  *
  * @param  p_clob     the CLOB to print to the DBMS_OUTPUT
  */
  PROCEDURE output_clob(p_clob IN CLOB);

  /**
  * Prints received data into the buffer
  *
  * @param  p_data     the data to print into buffer
  */
  PROCEDURE print(p_data IN CLOB);

  PROCEDURE p(p_data IN CLOB);

  PROCEDURE print(p_data IN VARCHAR2);

  PROCEDURE p(p_data IN VARCHAR2);

  PROCEDURE print(p_data IN NUMBER);

  PROCEDURE p(p_data IN NUMBER);

  /**
  * Renders the template received as parameter.
  *
  * @param  p_vars      the template's arguments.
  * @param  p_template  the template's body.
  * @return             the processed template.
  */
  FUNCTION render(p_vars     IN t_assoc_array DEFAULT null_assoc_array,
                  p_template IN CLOB)
    RETURN CLOB;

  /**
  * Receives the name of the object, usually a package,
  * which contains an embedded template.
  * The template is extracted and is rendered with `render` function
  *
  * @param  p_vars             the template's arguments.
  * @param  p_template_name    the name of the template
  * @param  p_object_name      the name of the object (usually the name of the package)
  * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
  * @param  p_schema           the object's schema name.
  * @return                    the processed template.
  */
  FUNCTION process(p_vars          IN t_assoc_array DEFAULT null_assoc_array,
                   p_template_name IN VARCHAR2      DEFAULT NULL,
                   p_object_name   IN VARCHAR2      DEFAULT 'TE_TEMPLATES',
                   p_object_type   IN VARCHAR2      DEFAULT 'PACKAGE',
                   p_schema        IN VARCHAR2      DEFAULT NULL)
    RETURN CLOB;
END teplsql;
/

CREATE OR REPLACE PACKAGE BODY teplsql
  AS
  g_buffer CLOB;

  PROCEDURE output_clob(p_clob IN CLOB)
  AS
    l_offset NUMBER DEFAULT 1;
  BEGIN
    LOOP
      EXIT WHEN l_offset > dbms_lob.getlength(p_clob);
      dbms_output.put_line(dbms_lob.substr(p_clob, 255, l_offset));
      l_offset := l_offset + 255;
    END LOOP;
  END output_clob;

  /**
  * Receives the template directive key-value data separated by commas
  * and assign this key-values to the associative array
  *
  * @param  p_directive      the key-value data template directive
  * @param  p_vars           the associative array
  */
  PROCEDURE set_template_directive(p_directive IN            CLOB,
                                   p_vars      IN OUT NOCOPY t_assoc_array)
  AS
    l_key       VARCHAR2(256);
    l_value     VARCHAR2(256);
    l_directive VARCHAR2(32767);
  BEGIN
    l_directive := REGEXP_REPLACE(p_directive, '\s', '');

    FOR c1 IN (SELECT REGEXP_REPLACE(REGEXP_SUBSTR(l_directive
      , '[^,]+'
      , 1
      , LEVEL), '\s', '')
      text
        FROM dual
      CONNECT BY REGEXP_SUBSTR(l_directive
      , '[^,]+'
      , 1
      , LEVEL) IS NOT NULL)
    LOOP
      l_key := SUBSTR(c1.text, 1, INSTR(c1.text, '=') - 1);
      l_value := SUBSTR(c1.text, INSTR(c1.text, '=') + 1);
      p_vars('template_' || l_key) := l_value;
    END LOOP;

  END set_template_directive;

  /**
  * Receives the name of the object, usually a package,
  * which contains an embedded template and return the template.
  *
  * @param  p_template_name    the name of the template
  * @param  p_object_name      the name of the object (usually the name of the package)
  * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
  * @param  p_schema           the schema of the object
  * @return                    the template.
  */
  FUNCTION include(p_template_name IN VARCHAR2 DEFAULT NULL,
                   p_object_name   IN VARCHAR2 DEFAULT 'TE_TEMPLATES',
                   p_object_type   IN VARCHAR2 DEFAULT 'PACKAGE',
                   p_schema        IN VARCHAR2 DEFAULT NULL)
    RETURN CLOB
  AS
    l_result        CLOB;
    l_object_ddl    CLOB;
    l_template      CLOB;
    l_tmp           CLOB;
    i               PLS_INTEGER := 1;
    l_found         PLS_INTEGER := 0;
    l_object_name   VARCHAR2(64);
    l_template_name VARCHAR2(64);
    l_object_type   VARCHAR2(64);
    l_schema        VARCHAR2(64);
  BEGIN

    --Force Defaults
    l_template_name := p_template_name;
    l_object_name := NVL(p_object_name, 'TE_TEMPLATES');
    l_object_type := NVL(p_object_type, 'PACKAGE');
    l_schema := p_schema;

    --Search for the template in the table TE_TEMPLATES
    IF l_template_name IS NOT NULL
      AND l_object_name = 'TE_TEMPLATES'
    THEN
      BEGIN
        SELECT template
          INTO l_template
          FROM te_templates
          WHERE name = UPPER(l_template_name);
      EXCEPTION
        WHEN no_data_found THEN
            l_template := EMPTY_CLOB();
      END;

      RETURN l_template;

    ELSE
      --Search the template in other Oracle Object

      --Get package source DDL
      l_object_ddl :=
      dbms_metadata.get_ddl(NVL(UPPER(l_object_type), 'PACKAGE'), UPPER(l_object_name), UPPER(l_schema));

      --If p_template_name is null get all templates from the object
      --else get only this template.
      IF l_template_name IS NOT NULL
      THEN
        LOOP
          l_tmp :=
          REGEXP_SUBSTR(l_object_ddl
          , '<%@ template([^%>].*?)%>'
          , 1
          , i
          , 'n');

          l_found := INSTR(l_tmp, 'name=' || l_template_name);

          EXIT WHEN LENGTH(l_tmp) = 0 OR l_found <> 0;
          i := i + 1;
        END LOOP;
      ELSE
        l_found := 0;
      END IF;

      -- i has the occurrence of the substr where the template is
      l_tmp := NULL;

      LOOP
             --Get Template from the object
             $IF DBMS_DB_VERSION.ver_le_10
             $THEN
                l_tmp       :=
                   REGEXP_REPLACE (REGEXP_REPLACE (REGEXP_SUBSTR (l_object_ddl
                                                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                                                , 1
                                                                , i
                                                                , 'n')
                                                 , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10)
                                                 , ''
                                                 , 1
                                                 , 1)
                                 , '\$end'
                                 , ''
                                 , 1
                                 , INSTR ('$end', 1, -1));
             $ELSE
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                , 1
                                , i
                                , 'n'
                                , 1);
             $END

             l_template  := l_template || l_tmp;
             EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
             i           := i + 1;
          END LOOP;

          RETURN l_template;
       END IF;
    END include;

   /**
   * Bind associative array variables in the template
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE bind_vars (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array)
   AS
      l_key   VARCHAR2 (256);
   BEGIN
      IF p_vars.COUNT () <> 0
      THEN
         l_key       := p_vars.FIRST;

         LOOP
            EXIT WHEN l_key IS NULL;
            p_template    := REPLACE (p_template, '${' || l_key || '}', TO_CLOB (p_vars (l_key)));
            l_key       := p_vars.NEXT (l_key);
         END LOOP;
      END IF;
   END bind_vars;

   /**
   * Parse template marks
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE parse (p_template IN CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_open_count    PLS_INTEGER;
      l_close_count   PLS_INTEGER;
   BEGIN
      $if dbms_db_version.ver_le_10 $then
          /**
          *  ATTENTION, these instructions are very slow and penalize template processing time.
          *  If performance is critical to your system, you should disable the parser only for BD <= 10g
          */
          l_open_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(<)%|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);

          l_close_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(%)>|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);
      $else
          l_open_count := regexp_count (p_template, '<\%');
          l_close_count := regexp_count (p_template, '\%>');
      $end


      IF l_open_count <> l_close_count
      THEN
         raise_application_error (-20001
                                ,    '##Parser Exception processing the template: '||p_vars('template_name')
                                  || '. One or more tags (<% %>) are not closed: '
                                  || l_open_count
                                  || ' <> '
                                  || l_close_count
                                  || CHR (10));
      END IF;
   END parse;

   /**
   * Interprets the received template and convert it into executable plsql
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE interpret (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_vars       t_assoc_array := p_vars;
      l_declare    CLOB;
      l_tmp        CLOB;
      i            PLS_INTEGER := 0;
   BEGIN

      --Template directive
      $if dbms_db_version.ver_le_10 $then
          l_tmp       :=
             REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                            , '<%@ template([^%>].*?)\s*%>'
                                            , 1
                                            , 1
                                            , 'n'), '<%@ template', ''), '%>', '');
      $else
          l_tmp       :=
             REGEXP_SUBSTR (p_template
                          , '<%@ template([^%>].*?)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);
      $end

      --Set template directive variables into var associative array
      set_template_directive (l_tmp, l_vars);

      --Bind the variables into template
      bind_vars (p_template, l_vars);

      --Null all variables not binded
      p_template    := REGEXP_REPLACE (p_template, '\$\{\S*\}', '');

      --Parse <% %> tags
      parse (p_template, l_vars);

      --Dos to Unix
      p_template  :=
         REGEXP_REPLACE (p_template
                       , CHR(13)||CHR(10)
                       , CHR(10)
                       , 1,0,'nm');

      --Delete all template directives
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%@ template([^%>].*?)\s*%>[[:blank:]]*\s$?'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Escaped chars except \\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '\\\\([^n])'
                       , ']'');tePLSQL.p(q''[\1]'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --New lines.
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(\\\\n)'
                       , CHR (10) --|| ']'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --Delete the line breaks for lines ending in %>[blanks]CHR(10)
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(%>[[:blank:]]*?' || CHR (10) || ')'
                       , '%>'
                       , 1
                       , 0
                       , '');

      --Delete new lines with !\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '([[:blank:]]*\!\\n[[:blank:]]*' || CHR (10) || '?[[:blank:]]*)'
                       , ''
                       , 1
                       , 0
                       , 'm');

      -- Delete all blanks before <% in the beginning of each line
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(^[[:blank:]]*<%)'
                       , '<%'
                       , 1
                       , 0
                       , 'm');

      --Merge all declaration blocks into a single block
      l_tmp       := NULL;

      LOOP
         i           := i + 1;
          $if dbms_db_version.ver_le_10 $then
             l_tmp       :=
                REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                               , '<%!([^%>].*?)%>'
                                               , 1
                                               , i
                                               , 'n'), '<%!', ''), '%>', '');
         $else
             l_tmp       :=
                REGEXP_SUBSTR (p_template
                             , '<%!([^%>].*?)%>'
                             , 1
                             , i
                             , 'n'
                             , 1);
         $end

         l_declare   := l_declare || l_tmp;
         EXIT WHEN LENGTH (l_tmp) = 0;
      END LOOP;

      --Delete declaration blocks from template
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%!([^%>].*?)%>'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Expresison directive
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%=([^%>].*?)%>'
                       , ']'');tePLSQL.p(\1);tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --Code blocks directive
      --p_template  :=
      --   REGEXP_REPLACE (p_template
      --                 , '<%([^%>].*?)%>'
      --                 , ']''); \1 tePLSQL.p(q''['
      --                , 1
      --                 , 0
      --                 , 'n');

      p_template  := 'DECLARE ' || l_declare || ' BEGIN tePLSQL.p(q''[' || p_template || ' ]''); END;';

   END interpret;

   /**
   * Search for include directives, includes and evaluates the specified templates.
   * Nested include are allowed
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE get_includes (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array )
    AS
       l_tmp             CLOB;
       l_result          CLOB;

       l_str_tmp         VARCHAR2 (64);

       TYPE array_t IS TABLE OF VARCHAR2 (64);

       l_strig_tt        array_t;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);

       l_start           PLS_INTEGER := 0;
       l_end             PLS_INTEGER := 0;
       l_number_includes PLS_INTEGER := 0;
    BEGIN
       /*
       --Pseudocode
       while there includes
       do
           get include
           interpret template
           concatenate result template into p_template
       done
       */
       WHILE REGEXP_INSTR (p_template, '<%@ include\((.*?)\)\s*%>') <> 0
       LOOP
          --Init
          l_str_tmp   := NULL;
          l_object_name := NULL;
          l_template_name := NULL;
          l_object_type := NULL;
          l_schema    := NULL;
          l_tmp       := NULL;
          l_start     := 0;
          l_end       := 0;

          --get include directive
          l_str_tmp   :=
             REGEXP_SUBSTR (p_template
                          , '<%@ include\((.*?)\)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);

          IF LENGTH (l_str_tmp) > 0
          THEN
                 SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_str_tmp
                                                       , '[^,]+'
                                                       , 1
                                                       , LEVEL), '\s', '')
                             text
                   BULK   COLLECT
                   INTO   l_strig_tt
                   FROM   DUAL
             CONNECT BY   REGEXP_SUBSTR (l_str_tmp
                                       , '[^,]+'
                                       , 1
                                       , LEVEL) IS NOT NULL;

             --populate variables
             IF l_strig_tt.EXISTS (1)
             THEN
                l_template_name := l_strig_tt (1);
             END IF;

             IF l_strig_tt.EXISTS (2)
             THEN
                l_object_name := l_strig_tt (2);
             END IF;

             IF l_strig_tt.EXISTS (3)
             THEN
                l_object_type := l_strig_tt (3);
             END IF;

             IF l_strig_tt.EXISTS (4)
             THEN
                l_schema    := l_strig_tt (4);
             END IF;

             --get included template
             l_tmp       :=
                include (l_template_name
                       , l_object_name
                       , l_object_type
                       , l_object_type);

             --Interpret the template
             interpret (l_tmp, p_vars);


             l_tmp := ']''); '|| l_tmp ||' tePLSQL.p(q''[';

             --Start and End of the expression
             l_start     :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 0
                            , 'n');

             l_end       :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 1
                            , 'n');

             --concatenate result template into first template
             IF (NVL (l_start, 0) > 0)
             THEN
                DBMS_LOB.createtemporary (l_result, FALSE, DBMS_LOB.call);

                IF l_start > 1
                THEN
                   DBMS_LOB.COPY (l_result
                                , p_template
                                , l_start - 1
                                , 1
                                , 1);
                END IF;

                IF LENGTH (l_tmp) > 0
                THEN
                   DBMS_LOB.COPY (l_result
                                , l_tmp
                                , DBMS_LOB.getlength (l_tmp)
                                , DBMS_LOB.getlength (l_result) +1
                                , 1);
                END IF;

                --Añadimos el resto de la fuente a la varbiable resultado
                DBMS_LOB.COPY (l_result
                             , p_template
                             , DBMS_LOB.getlength (p_template)
                             , DBMS_LOB.getlength (l_result) +1
                             , l_end);
             END IF;


             p_template  := l_result;

             DBMS_LOB.freetemporary (l_result);
          END IF;

          l_number_includes := l_number_includes +1;
          if l_number_includes >= 50
          then
            raise_application_error (-20001, 'Too much include directive in the template, Recursive include?');
          end if;

       END LOOP;
    END get_includes;

   PROCEDURE PRINT (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END PRINT;

   PROCEDURE p (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END p;

   FUNCTION render (p_vars IN t_assoc_array DEFAULT null_assoc_array, p_template IN CLOB)
      RETURN CLOB
   AS
    l_template   CLOB := p_template;
    l_length pls_integer;
   BEGIN
      --Clear buffer
      g_buffer    := NULL;

      --Parse <% %> tags
      --parse (l_template);

      --Get Includes
      get_includes(l_template);

      --Interpret the template
      interpret(l_template, p_vars);

      --Code blocks directive
      l_template  :=
         REGEXP_REPLACE (l_template
                       , '<%([^%>].*?)%>'
                       , ']''); \1 tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --DBMS_OUTPUT.put_line (l_template);

      --Execute the template
      $if dbms_db_version.ver_le_10 $then
          --10g
          DECLARE
             v_upperbound   NUMBER;
             v_cur          INTEGER;
             v_sql          DBMS_SQL.varchar2a;
             v_ret          NUMBER;
          BEGIN
             v_upperbound := CEIL (DBMS_LOB.getlength (l_template) / 32767);

             FOR i IN 1 .. v_upperbound
             LOOP
                v_sql (i)   := DBMS_LOB.SUBSTR (l_template, -- clob statement
                                                  32767, -- amount
                                                  ( (i - 1) * 32767) + 1);
             END LOOP;

             v_cur       := DBMS_SQL.open_cursor;
             -- parse sql statement
             DBMS_SQL.parse (v_cur
                           , v_sql
                           , 1
                           , v_upperbound
                           , FALSE
                           , DBMS_SQL.native);
             -- execute
             v_ret       := DBMS_SQL.execute (v_cur);
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;

      $else
          -- 11g
          BEGIN
             EXECUTE IMMEDIATE l_template;
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;
      $end

      l_template  := g_buffer;
      g_buffer    := NULL;

      RETURN l_template;
   EXCEPTION
      WHEN OTHERS
      THEN
         raise_application_error (-20001, SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
   END render;


   FUNCTION process (p_vars            IN t_assoc_array DEFAULT null_assoc_array
                   , p_template_name   IN VARCHAR2 DEFAULT NULL
                   , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                   , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                   , p_schema          IN VARCHAR2 DEFAULT NULL )
      RETURN CLOB
   AS
      l_result       CLOB;
      l_template     CLOB;
   BEGIN
      --Get template
      l_template := include(p_template_name,p_object_name,p_object_type,p_schema);

      IF LENGTH (l_template) = 0
      THEN
         IF p_template_name IS NOT NULL
         THEN
            raise_application_error (-20002
                                   , 'Template ' || p_template_name || ' not found in object ' || UPPER (p_object_name));
         ELSE
            raise_application_error (-20002
                                   , 'The object ' || p_object_name || ' not has a template inside the "$if false $then"');
         END IF;
      END IF;

      --Render template
      l_result    := render (p_vars,l_template);
      RETURN l_result;
   END process;
END teplsql;
/

--
-- Definition for package TAPI_GEN2
--
CREATE OR REPLACE PACKAGE tapi_gen2 AUTHID CURRENT_USER
  AS

  /**
  * TAPI_GEN2
  * Generated by: Oscar Salvador Magallanes
  * Website: github.com/osalvador/tapiGen2
  * Created On: 16-JUL-2015
  */

  --Global public data structures
  SUBTYPE dbo_name_t IS VARCHAR2(30); -- Max size for a DB object name

  TYPE dbo_name_aat IS TABLE OF dbo_name_t;

  TYPE column_rt IS RECORD (
      table_name      user_tab_columns.table_name % TYPE,
      column_name     user_tab_columns.column_name % TYPE,
      nullable        user_tab_columns.nullable % TYPE,
      constraint_type user_constraints.constraint_type % TYPE
    );

  --Collection types (record)
  TYPE column_tt IS TABLE OF column_rt;

  TYPE constraint_tt IS TABLE OF user_constraints % ROWTYPE;

  /**
  * Create PL/SQL Table API
  *
  * @param     p_table_name              must be NOT NULL
  * @param     p_compile_table_api       TRUE for compile generated package, FALSE to DBMS_OUTPUT the source
  * @param     p_unique_key              If the table has no primary key, it indicates the column that will be used as a unique key
  * @param     p_created_by_col_name     Custom audit column
  * @param     p_created_date_col_name   Custom audit column
  * @param     p_modified_by_col_name    Custom audit column
  * @param     p_modified_date_col_name  Custom audit column
  * @param     p_raise_exceptions        TRUE to use logger for exception handling
  */
  PROCEDURE create_tapi_package(p_table_name             IN VARCHAR2,
                                p_compile_table_api      IN BOOLEAN  DEFAULT TRUE,
                                p_unique_key             IN VARCHAR2 DEFAULT NULL,
                                p_created_by_col_name    IN VARCHAR2 DEFAULT NULL,
                                p_created_date_col_name  IN VARCHAR2 DEFAULT NULL,
                                p_modified_by_col_name   IN VARCHAR2 DEFAULT NULL,
                                p_modified_date_col_name IN VARCHAR2 DEFAULT NULL,
                                p_raise_exceptions       IN BOOLEAN  DEFAULT FALSE);

  --Public functions but for internal use.
  FUNCTION get_all_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

  FUNCTION get_pk_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

  FUNCTION get_noblob_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

--Spec Template
$if false $then
<%@ template
    name=spec
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_cont in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_cont > 1
         then
               teplsql.p(p_delimiter);
         end if;
    end; %>
CREATE OR REPLACE PACKAGE tapi_${table_name}
IS
   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   <% for i in 1 .. col.last loop %>
   SUBTYPE <%= col(i).COLUMN_NAME%> IS ${table_name}.<%= col(i).COLUMN_NAME%>%TYPE;
   <% end loop; %>

   --Record type
   TYPE ${table_name}_rt
   IS
      RECORD (
           <% c := col.last+1;
           for i in 1 .. col.last loop %>
            <%=  col(i).COLUMN_NAME%> ${table_name}.<%=col(i).COLUMN_NAME %>%TYPE,
           <% end loop; %>
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE ${table_name}_tt IS TABLE OF ${table_name}_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   FUNCTION hash (
              <% c := pk.last+1;
                for i in 1 .. pk.last loop %>
                  p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
             <% end loop; %>
               )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the ${table_name} table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt_for_update (
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
                      <% end loop; %>
                          )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   * This function return Record Table as PIPELINED Function
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Table Record Type
   */
   FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
               )
   RETURN ${table_name}_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the ${table_name} table.
   *
   * @param      p_${table_name}_rec       Record Type
   * @return     p_${table_name}_rec       Record Type
   */
   PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table.
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table,
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   PROCEDURE del (
              <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_${table_name};
$end


--Body Template
$if false $then
<%@ template
    name=body
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! noblob   tapi_gen2.column_tt := tapi_gen2.get_noblob_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_index in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_index > 1
         then
            teplsql.p(p_delimiter);
         end if;
    end; %>
<%! /*  User column for update */
   procedure column_for_update(p_column_name in varchar2,
                               p_ignore_nulls in boolean,
                               p_index in pls_integer,
                               p_blanks in pls_integer default 16)
   as
    l_blanks varchar2(256);
   begin
     for i in 1 .. p_blanks
     loop
        l_blanks := l_blanks ||' ';
     end loop;

      if ('${created_by_col_name}' <> p_column_name or '${created_by_col_name}' is null)
        and ('${created_date_col_name}' <> p_column_name or '${created_date_col_name}' is null)
     then
        if '${modified_by_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = USER /*dbax_core.g$username or apex_application.g_user*/');
        elsif '${modified_date_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = SYSDATE');
        else
           if p_ignore_nulls
           then
            teplsql.p(p_column_name || ' = ' || 'NVL(p_${table_name}_rec.'|| p_column_name ||','|| p_column_name ||')');
           else
            teplsql.p(p_column_name || ' = p_${table_name}_rec.' || p_column_name);
           end if;
        end if;

        sep(p_index,',\\n' || l_blanks);

     end if;
   end; %>
CREATE OR REPLACE PACKAGE BODY tapi_${table_name} IS

   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

  <% if '${raise_exceptions}' is not null then %>
    --Global logger scope
    gc_scope_prefix CONSTANT varchar2(31) := LOWER($$plsql_unit)||'.';
  <% end if; %>

   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ${table_name}_cur (
                    <% c := pk.last+1; for i in 1 .. pk.last loop %>
                       p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                    <% end loop; %>
                       )
   IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
            <%=col(i).column_name%>,
        <% end loop; %>
            tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
            ROWID
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = ${table_name}_cur.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

    --By Rowid
    CURSOR ${table_name}_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
             <%=col(i).column_name%>,
        <% end loop; %>
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             ROWID
      FROM ${table_name}
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                <% end loop; %>
                  )
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN

     <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
     <% end if; %>

     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
         <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = hash.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <%end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);
      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <%end if; %>
   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN
      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
      <% end if; %>

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
          <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <% end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>
      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END hash_rowid;

   FUNCTION rt (
            <% c := pk.last+1; for i in 1 .. pk.last loop %>
               p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
            <% end loop; %>
               )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt.p_<%=pk(i).column_name%><%sep(c-i,' AND ' );%>\\n
        <% end loop; %>
           ;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt;

   FUNCTION rt_for_update (
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                        <% end loop; %>
                          )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt_for_update';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt_for_update.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt_for_update;

    FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
                )
       RETURN ${table_name}_tt
       PIPELINED
    IS
       <% if '${raise_exceptions}' is not null then %>
       l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'tt';
       l_params logger.tab_param;
       <% end if; %>
       l_${table_name}_rec   ${table_name}_rt;
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', tt.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ${table_name} a
                   WHERE
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                        <%=pk(i).column_name%> = NVL(tt.p_<%=pk(i).column_name%>,<%=pk(i).column_name%>)<%sep(c-i,' AND ');%>\\n
                      <% end loop; %>
                        )
       LOOP
            <% for i in 1 .. col.last loop %>
              l_${table_name}_rec.<%=col(i).column_name%> := c1.<%=col(i).column_name%>;
            <% end loop; %>
              l_${table_name}_rec.hash := tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %> c1.<%=pk(i).column_name%><%sep(c-i,',');%><% end loop; %>);
              l_${table_name}_rec.row_id := c1.ROWID;
              PIPE ROW (l_${table_name}_rec);
       END LOOP;
       <% if '${raise_exceptions}' is not null then %>

       logger.LOG('END', l_scope);
       <% end if; %>

       RETURN;

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
    <% end if; %>
    END tt;


    PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt)
    IS
        <% if '${raise_exceptions}' is not null then %>
        l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'ins';
        l_params logger.tab_param;
       <% end if; %>
        l_rowtype     ${table_name}%ROWTYPE;
       <% if '${created_by_col_name}' is not null
        or   '${modified_by_col_name}' is not null
       then
            if '${created_by_col_name}' is not null
            then%>
        l_user_name   ${table_name}.${created_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <%else%>
        l_user_name   ${table_name}.${modified_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <% end if;
       end if;
       if '${created_date_col_name}' is not null
       or '${modified_date_col_name}' is not null
       then
            if '${created_date_col_name}' is not null
            then %>
        l_date        ${table_name}.${created_date_col_name}%TYPE := SYSDATE;
            <%else%>
        l_date        ${table_name}.${modified_date_col_name}%TYPE := SYSDATE;
            <% end if;
       end if; %>

    BEGIN
        <% if '${raise_exceptions}' is not null then
          for i in 1 .. col.last loop %>
        logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', ins.p_${table_name}_rec.<%=col(i).column_name%>);
        <% end loop; %>
        logger.LOG('START', l_scope, NULL, l_params);
        logger.LOG('Inserting data', l_scope);
        <% end if;%>

        <% if '${created_by_col_name}'Is not null then%>
        p_${table_name}_rec.${created_by_col_name} := l_user_name;
        <% end if; %>!\n
        <% if '${created_date_col_name}' is not null then %>
        p_${table_name}_rec.${created_date_col_name} := l_date;
        <% end if; %>!\n
        <% if '${modified_by_col_name}' is not null then %>
        p_${table_name}_rec.${modified_by_col_name} := l_user_name;
        <% end if;%>!\n
        <% if '${modified_date_col_name}' is not null then %>
        p_${table_name}_rec.${modified_date_col_name} := l_date;
        <% end if; %>

        <% for i in 1 .. col.last loop %>
        l_rowtype.<%=col(i).column_name%> := ins.p_${table_name}_rec.<%=col(i).column_name%>;
        <% end loop; %>

       INSERT INTO ${table_name}
         VALUES   l_rowtype;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
      WHEN OTHERS
      THEN
         logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
         RAISE;
    <% end if; %>
    END ins;

    PROCEDURE upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,false,c-i);
                 end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
      <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
      <% end if; %>
    END upd;


    PROCEDURE upd_rowid (
                         p_${table_name}_rec         IN ${table_name}_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,false,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END upd_rowid;

   PROCEDURE web_upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                             web_upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                        <% end loop; %>
                        );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,true,c-i, 23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            END IF;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_${table_name}_rec    IN ${table_name}_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_upd_rowid.p_${table_name}_rec.row_id);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,true,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            END IF;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd_rowid;

    PROCEDURE del (
               <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
               <% end loop; %>
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

       DELETE FROM   ${table_name}
             WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  <%=pk(i).column_name%> = del.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
       <% if '${raise_exceptions}' is not null then %>
       logger.append_param(l_params, 'p_rowid', del_rowid.p_rowid);
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Deleting record', l_scope);
       <% end if; %>

       DELETE FROM   ${table_name}
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del_rowid;

    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', web_del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                          <% c := pk.last+1; for i in 1 .. pk.last loop %>
                            web_del.p_<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                          <% end loop; %>
                            );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_cur;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;


      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', web_del_rowid.p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_del_rowid.p_rowid);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_rowid_cur;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

     <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
     <%end if; %>
   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del_rowid;

END tapi_${table_name};

$end

END tapi_gen2;
/

CREATE OR REPLACE PACKAGE BODY tapi_gen2
  AS
  --Global private variables
  g_unque_key dbo_name_t;

  PROCEDURE create_tapi_package(p_table_name             IN VARCHAR2,
                                p_compile_table_api      IN BOOLEAN  DEFAULT TRUE,
                                p_unique_key             IN VARCHAR2 DEFAULT NULL,
                                p_created_by_col_name    IN VARCHAR2 DEFAULT NULL,
                                p_created_date_col_name  IN VARCHAR2 DEFAULT NULL,
                                p_modified_by_col_name   IN VARCHAR2 DEFAULT NULL,
                                p_modified_date_col_name IN VARCHAR2 DEFAULT NULL,
                                p_raise_exceptions       IN BOOLEAN  DEFAULT FALSE)
  AS
    l_count      PLS_INTEGER := 0;
    l_table_name dbo_name_t  := LOWER(p_table_name);
    l_vars       teplsql.t_assoc_array;
    l_spec_tapi  CLOB;
    l_body_tapi  CLOB;
  BEGIN
    /*Validations*/

    --check_table_exists
    SELECT COUNT(*)
      INTO l_count
      FROM user_tables
      WHERE UPPER(table_name) = UPPER(l_table_name);

    IF l_count = 0
    THEN
      RAISE_APPLICATION_ERROR(-20000, 'Table ' || l_table_name || ' does not exist!');
    END IF;

    --Check table hash PK or p_unique_key is not null
    IF p_unique_key IS NULL
    THEN
      SELECT COUNT(*)
        INTO l_count
        FROM user_constraints
        WHERE UPPER(table_name) = UPPER(l_table_name)
          AND constraint_type = 'P';

      IF l_count = 0
      THEN
        RAISE_APPLICATION_ERROR(-20000
        , 'Table '
        || l_table_name
        || ' does not have a Primary Key'
        || ' and P_UNIQUE_KEY parameter is null');
      END IF;
    END IF;

    --Init variables for render template
    l_vars('date') := TO_CHAR(sysdate, 'DD-MON-YYYY HH24:MI');
    l_vars('table_name') := l_table_name;
    l_vars('user') := USER;
    l_vars('created_by_col_name') := p_created_by_col_name;
    l_vars('created_date_col_name') := p_created_date_col_name;
    l_vars('modified_by_col_name') := p_modified_by_col_name;
    l_vars('modified_date_col_name') := p_modified_date_col_name;
    l_vars('result_cache') := 'RESULT_CACHE';

    IF p_raise_exceptions
    THEN
      l_vars('raise_exceptions') := 'TRUE';
    ELSE
      l_vars('raise_exceptions') := '';
    END IF;

    --If the table hash LOBS columns, disable result_cache.
    FOR c1 IN (SELECT *
        FROM user_tab_cols
        WHERE table_name = UPPER(l_table_name)
          AND data_type IN ('BLOB', 'CLOB'))
    LOOP
      l_vars('result_cache') := '';
    END LOOP;

    --Define unique key if table don't hace primary key
    g_unque_key := p_unique_key;

    -- Spec --
    --Process template
    l_spec_tapi := teplsql.process(l_vars, 'spec', 'TAPI_GEN2');

    -- Body --
    --Process template
    l_body_tapi := teplsql.process(l_vars, 'body', 'TAPI_GEN2');

    IF p_compile_table_api
    THEN
      BEGIN
        EXECUTE IMMEDIATE l_spec_tapi;
      EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(l_spec_tapi);
            RAISE_APPLICATION_ERROR(-20000, 'Spec compiled with error(s)! ' || sqlerrm);
      END;

      BEGIN
        EXECUTE IMMEDIATE l_body_tapi;
      EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20000, ' Body compiled with error(s)! ' || sqlerrm);
      END;

      dbms_output.put_line('Creation of Table API package for ' || l_table_name || ' table completed successfully!');
    ELSE
      dbms_output.put_line(l_spec_tapi);
      dbms_output.put_line(l_body_tapi);
    END IF;
  END create_tapi_package;


  FUNCTION get_all_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    SELECT c.table_name,
           LOWER(c.column_name),
           c.nullable,
           '' constraint_type
      BULK COLLECT
      INTO l_tt
      FROM user_tab_columns c
      WHERE c.table_name = UPPER(p_tab_name)
      ORDER BY c.column_id;

    RETURN l_tt;
  END;

  FUNCTION get_pk_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    IF g_unque_key IS NOT NULL
    THEN
      IF NOT l_tt.EXISTS(1)
      THEN
        l_tt := column_tt(NULL);
      END IF;

      l_tt(1).table_name := p_tab_name;
      l_tt(1).column_name := LOWER(g_unque_key);
      l_tt(1).nullable := 'N';
      l_tt(1).constraint_type := 'P';
    ELSE
      SELECT c.table_name,
             LOWER(c.column_name),
             c.nullable,
             cs.constraint_type
        BULK COLLECT
        INTO l_tt
        FROM user_tab_columns c
          LEFT JOIN user_cons_columns cc
            ON c.table_name = cc.table_name
            AND c.column_name = cc.column_name
            LEFT JOIN user_constraints cs
              ON cc.constraint_name = cs.constraint_name
        WHERE c.table_name = UPPER(p_tab_name)
          AND cs.constraint_type = 'P'
        ORDER BY c.column_id;
    END IF;

    RETURN l_tt;
  END;


  FUNCTION get_noblob_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    SELECT c.table_name,
           LOWER(c.column_name),
           c.nullable,
           '' constraint_type
      BULK COLLECT
      INTO l_tt
      FROM user_tab_columns c
      WHERE table_name = UPPER(p_tab_name)
        AND column_name NOT IN (SELECT column_name
            FROM user_tab_cols
            WHERE table_name = UPPER(p_tab_name)
              AND data_type = 'BLOB')
      ORDER BY column_id;

    RETURN l_tt;
  END;
END tapi_gen2;

/

--
-- Definition for procedure LOGGER_CONFIGURE
--
CREATE OR REPLACE PROCEDURE logger_configure
IS
  -- Note: The license is defined in the package specification of the logger package
  --
  l_rac_lt_11_2          VARCHAR2(50)   := 'FALSE';  -- is this a RAC instance less than 11.2, no GAC support

  l_apex                 VARCHAR2(50)   := 'FALSE';
  tbl_not_exist          EXCEPTION;
  pls_pkg_not_exist      EXCEPTION;

  l_text_data_length     user_tab_columns.data_length % TYPE;
  l_large_text_column    VARCHAR2(50);

  l_sql                  VARCHAR2(32767);
  l_variables            VARCHAR2(1000) := ' ';
  l_dummy                NUMBER;
  l_flashback            VARCHAR2(50)   := 'FALSE';
  l_utl_lms              VARCHAR2(5)    := 'FALSE';

  PRAGMA EXCEPTION_INIT (tbl_not_exist, -942);
  PRAGMA EXCEPTION_INIT (pls_pkg_not_exist, -06550);

  l_version     CONSTANT NUMBER         := dbms_db_version.version + (dbms_db_version.release / 10);
  l_pref_value           logger_prefs.pref_value % TYPE;
  l_logger_debug         BOOLEAN;

  l_pref_type_logger     logger_prefs.pref_type % TYPE;
BEGIN

  -- Check to see if we are in a RAC Database, 11.1 or lower.
  --
  -- Tyler to check if this works
  IF dbms_utility.is_cluster_database
  THEN
    l_rac_lt_11_2 := 'TRUE';
  ELSE
    l_rac_lt_11_2 := 'FALSE';
  END IF;

  IF l_version >= 11.2
  THEN
    l_rac_lt_11_2 := 'FALSE';
  END IF;

  l_variables := 'RAC_LT_11_2:' || l_rac_lt_11_2 || ',';


  -- Check lenth of TEXT size (this is for future 12c 32767 integration
  -- In support of Issue #17 and future proofing for #30
  SELECT data_length
    INTO l_text_data_length
    FROM user_tab_columns
    WHERE 1 = 1
      AND table_name = 'LOGGER_LOGS'
      AND column_name = 'TEXT';

  IF l_text_data_length > 4000
  THEN
    l_large_text_column := 'TRUE';
  ELSE
    l_large_text_column := 'FALSE';
  END IF;
  l_variables := l_variables || 'LARGE_TEXT_COLUMN:' || l_large_text_column || ',';


  -- Is APEX installed ?
  --
  BEGIN
    EXECUTE IMMEDIATE 'select 1 from apex_application_items where rownum = 1'
      INTO l_dummy;

    l_apex := 'TRUE';
  EXCEPTION
    WHEN tbl_not_exist THEN
        l_apex := 'FALSE';
    WHEN no_data_found THEN
        l_apex := 'TRUE';
  END;

  l_variables := l_variables || 'APEX:' || l_apex || ',';


  -- Can we call dbms_flashback to get the currect System Commit Number?
  --
  BEGIN
    EXECUTE IMMEDIATE 'begin :d := dbms_flashback.get_system_change_number; end; '
    USING OUT l_dummy;

    l_flashback := 'TRUE';
  EXCEPTION
    WHEN pls_pkg_not_exist THEN
        l_flashback := 'FALSE';
  END;

  l_variables := l_variables || 'FLASHBACK_ENABLED:' || l_flashback || ',';


  -- #64: Support to run Logger in debug mode

  -- #127
  -- Since this procedure will recompile Logger, if it directly references a variable in Logger
  -- It will lock itself while trying to recompile
  -- Work around is to pre-store the variable using execute immediate
  EXECUTE IMMEDIATE 'begin :x := logger.g_pref_type_logger; end;'
  USING OUT l_pref_type_logger;

  SELECT lp.pref_value
    INTO l_pref_value
    FROM logger_prefs lp
    WHERE 1 = 1
      AND lp.pref_type = UPPER(l_pref_type_logger)
      AND lp.pref_name = 'LOGGER_DEBUG';
  l_variables := l_variables || 'LOGGER_DEBUG:' || l_pref_value || ',';

  l_logger_debug := FALSE;
  IF UPPER(l_pref_value) = 'TRUE'
  THEN
    l_logger_debug := TRUE;
  END IF;


  -- #46
  -- Handle plugin settings
  -- Set for each plugin type
  FOR x IN (SELECT 'LOGGER_' ||
    REGEXP_REPLACE(lp.pref_name, '^PLUGIN_FN_', 'PLUGIN_') || ':' ||
    DECODE(NVL(UPPER(lp.pref_value), 'NONE'), 'NONE', 'FALSE', 'TRUE') ||
    ',' var
      FROM logger_prefs lp
      WHERE 1 = 1
        AND lp.pref_type = l_pref_type_logger
        AND lp.pref_name LIKE 'PLUGIN_FN%')
  LOOP
    l_variables := l_variables || x.var;
  END LOOP;


  l_variables := RTRIM(l_variables, ',');
  IF l_logger_debug
  THEN
    dbms_output.put_line('l_variables: ' || l_variables);
  END IF;


  -- Recompile Logger
  l_sql := q'!alter package logger compile body PLSQL_CCFLAGS='%VARIABLES%' reuse settings!';
  l_sql := REPLACE(l_sql, '%VARIABLES%', l_variables);
  EXECUTE IMMEDIATE l_sql;

  -- #31: Dropped trigger
  -- l_sql := q'[alter trigger BI_LOGGER_LOGS compile PLSQL_CCFLAGS=']'||l_variables||q'[' reuse settings]';
  -- execute immediate l_sql;

  l_sql := q'!alter trigger biu_logger_prefs compile PLSQL_CCFLAGS='CURRENTLY_INSTALLING:FALSE'!';
  EXECUTE IMMEDIATE l_sql;

  -- just in case this is a re-install / upgrade, the global contexts will persist so reset them
  logger.null_global_contexts;

END logger_configure;
/

--
-- Definition for view LOGGER_LOGS_5_MIN
--
CREATE OR REPLACE VIEW logger_logs_5_min (
  id,
  logger_level,
  text,
  time_stamp,
  scope,
  module,
  action,
  user_name,
  client_identifier,
  call_stack,
  unit_name,
  line_no,
  scn,
  extra,
  sid,
  client_info
) AS
    SELECT "ID",
           "LOGGER_LEVEL",
           "TEXT",
           "TIME_STAMP",
           "SCOPE",
           "MODULE",
           "ACTION",
           "USER_NAME",
           "CLIENT_IDENTIFIER",
           "CALL_STACK",
           "UNIT_NAME",
           "LINE_NO",
           "SCN",
           "EXTRA",
           "SID",
           "CLIENT_INFO"
      FROM logger_logs
      WHERE time_stamp > systimestamp - (5 / 1440);

--
-- Definition for view LOGGER_LOGS_60_MIN
--
CREATE OR REPLACE VIEW logger_logs_60_min (
  id,
  logger_level,
  text,
  time_stamp,
  scope,
  module,
  action,
  user_name,
  client_identifier,
  call_stack,
  unit_name,
  line_no,
  scn,
  extra,
  sid,
  client_info
) AS
    SELECT "ID",
           "LOGGER_LEVEL",
           "TEXT",
           "TIME_STAMP",
           "SCOPE",
           "MODULE",
           "ACTION",
           "USER_NAME",
           "CLIENT_IDENTIFIER",
           "CALL_STACK",
           "UNIT_NAME",
           "LINE_NO",
           "SCN",
           "EXTRA",
           "SID",
           "CLIENT_INFO"
      FROM logger_logs
      WHERE time_stamp > systimestamp - (1 / 24);

--
-- Definition for view LOGGER_LOGS_TERSE
--
CREATE OR REPLACE VIEW logger_logs_terse (
  id,
  logger_level,
  time_ago,
  text
) AS
    SELECT id,
           logger_level,
           SUBSTR(logger.date_text_format(time_stamp), 1, 20) time_ago,
           SUBSTR(text, 1, 200) text
      FROM logger_logs
      WHERE time_stamp > systimestamp - (5 / 1440)
      ORDER BY id ASC;

--
-- Dumping data for table LOGGER_LOGS
--
DECLARE
TMP_CLOB_13 CLOB := NULL;
SRC_CHUNK_13 VARCHAR2(12001);
BEGIN
INSERT INTO LOGGER_LOGS VALUES
(1, 8, 'Log level set to DEBUG for client_id: <global>, include_call_stack=TRUE by Host: WORKGROUP\TL-SIST03, IP: 127.0.0.1, TERMINAL: TL-SIST03, OS_USER: TL-SIST03\pjaraba, CURRENT_USER: SIMPLE_DELIVERY, SESSION_USER: SIMPLE_DELIVERY', '07/19/2016 12:46:10.065000000', NULL, 'SQL*Plus', NULL, 'SIMPLE_DELIVERY', NULL, NULL, NULL, NULL, NULL, NULL, 249, NULL);
INSERT INTO LOGGER_LOGS VALUES
(2, 1, 'Logger version 3.1.0 installed.', '07/19/2016 12:46:10.149000000', NULL, 'SQL*Plus', NULL, 'SIMPLE_DELIVERY', NULL, '  object      line  object'||CHR(10)
||'  handle    number  name'||CHR(10)
||'00007FFD1BC6C4E0         2  anonymous block'||CHR(10)
, NULL, NULL, NULL, NULL, 249, NULL);
END;
/

--
-- Dumping data for table LOGGER_PREFS
--
INSERT INTO LOGGER_PREFS VALUES
('LEVEL', 'DEBUG', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PURGE_MIN_LEVEL', 'DEBUG', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PROTECT_ADMIN_PROCS', 'TRUE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('LOGGER_VERSION', '3.1.0', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('LOGGER_DEBUG', 'FALSE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('INSTALL_SCHEMA', 'SIMPLE_DELIVERY', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('INCLUDE_CALL_STACK', 'TRUE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PLUGIN_FN_ERROR', 'NONE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PURGE_AFTER_DAYS', '7', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PREF_BY_CLIENT_ID_EXPIRE_HOURS', '12', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('GLOBAL_CONTEXT_NAME', 'SIMPLE_DELIVERY_LOGCTX', 'LOGGER');

--
-- Dumping data for table LOGGER_PREFS_BY_CLIENT_ID
--

-- Table SIMPLE_DELIVERY.LOGGER_PREFS_BY_CLIENT_ID does not contain any data (it is empty)

--
-- Dumping data for table TE_TEMPLATES
--

-- Table SIMPLE_DELIVERY.TE_TEMPLATES does not contain any data (it is empty)

--
-- Dumping data for table LOGGER_LOGS_APEX_ITEMS
--

-- Table SIMPLE_DELIVERY.LOGGER_LOGS_APEX_ITEMS does not contain any data (it is empty)

--
-- Definition for trigger BIU_LOGGER_APEX_ITEMS
--
CREATE OR REPLACE TRIGGER biu_logger_apex_items
  BEFORE INSERT OR UPDATE
  ON logger_logs_apex_items
  FOR EACH ROW
BEGIN
$if $$logger_no_op_install $then
  null;
$else
  :new.id := logger_apx_items_seq.nextval;
$end
END;

/

--
-- Definition for trigger BIU_LOGGER_PREFS
--
CREATE OR REPLACE TRIGGER biu_logger_prefs
  BEFORE INSERT OR UPDATE
  ON logger_prefs
  FOR EACH ROW
BEGIN
$if $$logger_no_op_install $then
  null;
$else
  :new.pref_name := upper(:new.pref_name);
  :new.pref_type := upper(:new.pref_type);

  if 1=1
    and :new.pref_type = logger.g_pref_type_logger
    and :new.pref_name = 'LEVEL' then
    :new.pref_value := upper(:new.pref_value);
  end if;

  $if $$currently_installing is null or not $$currently_installing $then
    -- Since logger.pks may not be installed when this trigger is compiled, need to move some code here
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name = 'LEVEL'
      and upper(:new.pref_value) not in (logger.g_off_name, logger.g_permanent_name, logger.g_error_name, logger.g_warning_name, logger.g_information_name, logger.g_debug_name, logger.g_timing_name, logger.g_sys_context_name, logger.g_apex_name) then
      raise_application_error(-20000, '"LEVEL" must be one of the following values: ' ||
        logger.g_off_name || ', ' || logger.g_permanent_name || ', ' || logger.g_error_name || ', ' ||
        logger.g_warning_name || ', ' || logger.g_information_name || ', ' || logger.g_debug_name || ', ' ||
        logger.g_timing_name || ', ' || logger.g_sys_context_name || ', ' || logger.g_apex_name);
    end if;

    -- Allow for null to be used for Plugins, then default to NONE
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name like 'PLUGIN_FN%'
      and :new.pref_value is null then
      :new.pref_value := 'NONE';
    end if;

    -- #103
    -- Only predefined preferences and Custom Preferences are allowed
    -- Custom Preferences must be prefixed with CUST_
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name not in (
        'GLOBAL_CONTEXT_NAME'
        ,'INCLUDE_CALL_STACK'
        ,'INSTALL_SCHEMA'
        ,'LEVEL'
        ,'LOGGER_DEBUG'
        ,'LOGGER_VERSION'
        ,'PLUGIN_FN_ERROR'
        ,'PREF_BY_CLIENT_ID_EXPIRE_HOURS'
        ,'PROTECT_ADMIN_PROCS'
        ,'PURGE_AFTER_DAYS'
        ,'PURGE_MIN_LEVEL'
      )
    then
      raise_application_error (-20000, 'Setting system level preferences are restricted to a set list.');
    end if;

    -- this is because the logger package is not installed yet.  We enable it in logger_configure
    logger.null_global_contexts;
  $end
$end -- $$logger_no_op_install
END;

/

COMMIT;
ALTER PACKAGE logger COMPILE;
ALTER PACKAGE logger COMPILE BODY;
--
-- Set default schema
--
DECLARE
  p VARCHAR2(255);
BEGIN
  SELECT USER INTO p FROM DUAL;
  EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = ' || p;
END;
/
