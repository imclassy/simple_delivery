--
-- Script was generated by Devart dbForge Studio for Oracle, Version 3.7.472.0
-- Product home page: http://www.devart.com/dbforge/oracle/studio
-- Script date 7/19/2016 12:57:53 PM
-- Server version: Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options
-- Client version: 12.1.0.0
--


CONNECT simple_delivery/123456@pdborcl;


--
-- Set default schema
--
ALTER SESSION SET CURRENT_SCHEMA = "SIMPLE_DELIVERY";

SET SQLBLANKLINES ON;
SET DEFINE OFF;
ALTER SESSION SET NLS_DATE_FORMAT = 'MM/DD/SYYYY HH24:MI:SS';
ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF';
ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,';
ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE;
ALTER SESSION SET TIME_ZONE = '-05:00';

--
-- Definition for package TEPLSQL
--
CREATE OR REPLACE PACKAGE teplsql
  AS
  --Define Associative Array
  TYPE t_assoc_array IS TABLE OF VARCHAR2(32767)
    INDEX BY VARCHAR2 (255);

  null_assoc_array t_assoc_array;

  /**
  * Output CLOB data to the DBMS_OUTPUT.PUT_LINE
  *
  * @param  p_clob     the CLOB to print to the DBMS_OUTPUT
  */
  PROCEDURE output_clob(p_clob IN CLOB);

  /**
  * Prints received data into the buffer
  *
  * @param  p_data     the data to print into buffer
  */
  PROCEDURE print(p_data IN CLOB);

  PROCEDURE p(p_data IN CLOB);

  PROCEDURE print(p_data IN VARCHAR2);

  PROCEDURE p(p_data IN VARCHAR2);

  PROCEDURE print(p_data IN NUMBER);

  PROCEDURE p(p_data IN NUMBER);

  /**
  * Renders the template received as parameter.
  *
  * @param  p_vars      the template's arguments.
  * @param  p_template  the template's body.
  * @return             the processed template.
  */
  FUNCTION render(p_vars     IN t_assoc_array DEFAULT null_assoc_array,
                  p_template IN CLOB)
    RETURN CLOB;

  /**
  * Receives the name of the object, usually a package,
  * which contains an embedded template.
  * The template is extracted and is rendered with `render` function
  *
  * @param  p_vars             the template's arguments.
  * @param  p_template_name    the name of the template
  * @param  p_object_name      the name of the object (usually the name of the package)
  * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
  * @param  p_schema           the object's schema name.
  * @return                    the processed template.
  */
  FUNCTION process(p_vars          IN t_assoc_array DEFAULT null_assoc_array,
                   p_template_name IN VARCHAR2      DEFAULT NULL,
                   p_object_name   IN VARCHAR2      DEFAULT 'TE_TEMPLATES',
                   p_object_type   IN VARCHAR2      DEFAULT 'PACKAGE',
                   p_schema        IN VARCHAR2      DEFAULT NULL)
    RETURN CLOB;
END teplsql;
/

CREATE OR REPLACE PACKAGE BODY teplsql
  AS
  g_buffer CLOB;

  PROCEDURE output_clob(p_clob IN CLOB)
  AS
    l_offset NUMBER DEFAULT 1;
  BEGIN
    LOOP
      EXIT WHEN l_offset > dbms_lob.getlength(p_clob);
      dbms_output.put_line(dbms_lob.substr(p_clob, 255, l_offset));
      l_offset := l_offset + 255;
    END LOOP;
  END output_clob;

  /**
  * Receives the template directive key-value data separated by commas
  * and assign this key-values to the associative array
  *
  * @param  p_directive      the key-value data template directive
  * @param  p_vars           the associative array
  */
  PROCEDURE set_template_directive(p_directive IN            CLOB,
                                   p_vars      IN OUT NOCOPY t_assoc_array)
  AS
    l_key       VARCHAR2(256);
    l_value     VARCHAR2(256);
    l_directive VARCHAR2(32767);
  BEGIN
    l_directive := REGEXP_REPLACE(p_directive, '\s', '');

    FOR c1 IN (SELECT REGEXP_REPLACE(REGEXP_SUBSTR(l_directive
      , '[^,]+'
      , 1
      , LEVEL), '\s', '')
      text
        FROM dual
      CONNECT BY REGEXP_SUBSTR(l_directive
      , '[^,]+'
      , 1
      , LEVEL) IS NOT NULL)
    LOOP
      l_key := SUBSTR(c1.text, 1, INSTR(c1.text, '=') - 1);
      l_value := SUBSTR(c1.text, INSTR(c1.text, '=') + 1);
      p_vars('template_' || l_key) := l_value;
    END LOOP;

  END set_template_directive;

  /**
  * Receives the name of the object, usually a package,
  * which contains an embedded template and return the template.
  *
  * @param  p_template_name    the name of the template
  * @param  p_object_name      the name of the object (usually the name of the package)
  * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
  * @param  p_schema           the schema of the object
  * @return                    the template.
  */
  FUNCTION include(p_template_name IN VARCHAR2 DEFAULT NULL,
                   p_object_name   IN VARCHAR2 DEFAULT 'TE_TEMPLATES',
                   p_object_type   IN VARCHAR2 DEFAULT 'PACKAGE',
                   p_schema        IN VARCHAR2 DEFAULT NULL)
    RETURN CLOB
  AS
    l_result        CLOB;
    l_object_ddl    CLOB;
    l_template      CLOB;
    l_tmp           CLOB;
    i               PLS_INTEGER := 1;
    l_found         PLS_INTEGER := 0;
    l_object_name   VARCHAR2(64);
    l_template_name VARCHAR2(64);
    l_object_type   VARCHAR2(64);
    l_schema        VARCHAR2(64);
  BEGIN

    --Force Defaults
    l_template_name := p_template_name;
    l_object_name := NVL(p_object_name, 'TE_TEMPLATES');
    l_object_type := NVL(p_object_type, 'PACKAGE');
    l_schema := p_schema;

    --Search for the template in the table TE_TEMPLATES
    IF l_template_name IS NOT NULL
      AND l_object_name = 'TE_TEMPLATES'
    THEN
      BEGIN
        SELECT template
          INTO l_template
          FROM te_templates
          WHERE name = UPPER(l_template_name);
      EXCEPTION
        WHEN no_data_found THEN
            l_template := EMPTY_CLOB();
      END;

      RETURN l_template;

    ELSE
      --Search the template in other Oracle Object

      --Get package source DDL
      l_object_ddl :=
      dbms_metadata.get_ddl(NVL(UPPER(l_object_type), 'PACKAGE'), UPPER(l_object_name), UPPER(l_schema));

      --If p_template_name is null get all templates from the object
      --else get only this template.
      IF l_template_name IS NOT NULL
      THEN
        LOOP
          l_tmp :=
          REGEXP_SUBSTR(l_object_ddl
          , '<%@ template([^%>].*?)%>'
          , 1
          , i
          , 'n');

          l_found := INSTR(l_tmp, 'name=' || l_template_name);

          EXIT WHEN LENGTH(l_tmp) = 0 OR l_found <> 0;
          i := i + 1;
        END LOOP;
      ELSE
        l_found := 0;
      END IF;

      -- i has the occurrence of the substr where the template is
      l_tmp := NULL;

      LOOP
             --Get Template from the object
             $IF DBMS_DB_VERSION.ver_le_10
             $THEN
                l_tmp       :=
                   REGEXP_REPLACE (REGEXP_REPLACE (REGEXP_SUBSTR (l_object_ddl
                                                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                                                , 1
                                                                , i
                                                                , 'n')
                                                 , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10)
                                                 , ''
                                                 , 1
                                                 , 1)
                                 , '\$end'
                                 , ''
                                 , 1
                                 , INSTR ('$end', 1, -1));
             $ELSE
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                , 1
                                , i
                                , 'n'
                                , 1);
             $END

             l_template  := l_template || l_tmp;
             EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
             i           := i + 1;
          END LOOP;

          RETURN l_template;
       END IF;
    END include;

   /**
   * Bind associative array variables in the template
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE bind_vars (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array)
   AS
      l_key   VARCHAR2 (256);
   BEGIN
      IF p_vars.COUNT () <> 0
      THEN
         l_key       := p_vars.FIRST;

         LOOP
            EXIT WHEN l_key IS NULL;
            p_template    := REPLACE (p_template, '${' || l_key || '}', TO_CLOB (p_vars (l_key)));
            l_key       := p_vars.NEXT (l_key);
         END LOOP;
      END IF;
   END bind_vars;

   /**
   * Parse template marks
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE parse (p_template IN CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_open_count    PLS_INTEGER;
      l_close_count   PLS_INTEGER;
   BEGIN
      $if dbms_db_version.ver_le_10 $then
          /**
          *  ATTENTION, these instructions are very slow and penalize template processing time.
          *  If performance is critical to your system, you should disable the parser only for BD <= 10g
          */
          l_open_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(<)%|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);

          l_close_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(%)>|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);
      $else
          l_open_count := regexp_count (p_template, '<\%');
          l_close_count := regexp_count (p_template, '\%>');
      $end


      IF l_open_count <> l_close_count
      THEN
         raise_application_error (-20001
                                ,    '##Parser Exception processing the template: '||p_vars('template_name')
                                  || '. One or more tags (<% %>) are not closed: '
                                  || l_open_count
                                  || ' <> '
                                  || l_close_count
                                  || CHR (10));
      END IF;
   END parse;

   /**
   * Interprets the received template and convert it into executable plsql
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE interpret (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_vars       t_assoc_array := p_vars;
      l_declare    CLOB;
      l_tmp        CLOB;
      i            PLS_INTEGER := 0;
   BEGIN

      --Template directive
      $if dbms_db_version.ver_le_10 $then
          l_tmp       :=
             REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                            , '<%@ template([^%>].*?)\s*%>'
                                            , 1
                                            , 1
                                            , 'n'), '<%@ template', ''), '%>', '');
      $else
          l_tmp       :=
             REGEXP_SUBSTR (p_template
                          , '<%@ template([^%>].*?)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);
      $end

      --Set template directive variables into var associative array
      set_template_directive (l_tmp, l_vars);

      --Bind the variables into template
      bind_vars (p_template, l_vars);

      --Null all variables not binded
      p_template    := REGEXP_REPLACE (p_template, '\$\{\S*\}', '');

      --Parse <% %> tags
      parse (p_template, l_vars);

      --Dos to Unix
      p_template  :=
         REGEXP_REPLACE (p_template
                       , CHR(13)||CHR(10)
                       , CHR(10)
                       , 1,0,'nm');

      --Delete all template directives
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%@ template([^%>].*?)\s*%>[[:blank:]]*\s$?'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Escaped chars except \\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '\\\\([^n])'
                       , ']'');tePLSQL.p(q''[\1]'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --New lines.
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(\\\\n)'
                       , CHR (10) --|| ']'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --Delete the line breaks for lines ending in %>[blanks]CHR(10)
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(%>[[:blank:]]*?' || CHR (10) || ')'
                       , '%>'
                       , 1
                       , 0
                       , '');

      --Delete new lines with !\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '([[:blank:]]*\!\\n[[:blank:]]*' || CHR (10) || '?[[:blank:]]*)'
                       , ''
                       , 1
                       , 0
                       , 'm');

      -- Delete all blanks before <% in the beginning of each line
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(^[[:blank:]]*<%)'
                       , '<%'
                       , 1
                       , 0
                       , 'm');

      --Merge all declaration blocks into a single block
      l_tmp       := NULL;

      LOOP
         i           := i + 1;
          $if dbms_db_version.ver_le_10 $then
             l_tmp       :=
                REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                               , '<%!([^%>].*?)%>'
                                               , 1
                                               , i
                                               , 'n'), '<%!', ''), '%>', '');
         $else
             l_tmp       :=
                REGEXP_SUBSTR (p_template
                             , '<%!([^%>].*?)%>'
                             , 1
                             , i
                             , 'n'
                             , 1);
         $end

         l_declare   := l_declare || l_tmp;
         EXIT WHEN LENGTH (l_tmp) = 0;
      END LOOP;

      --Delete declaration blocks from template
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%!([^%>].*?)%>'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Expresison directive
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%=([^%>].*?)%>'
                       , ']'');tePLSQL.p(\1);tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --Code blocks directive
      --p_template  :=
      --   REGEXP_REPLACE (p_template
      --                 , '<%([^%>].*?)%>'
      --                 , ']''); \1 tePLSQL.p(q''['
      --                , 1
      --                 , 0
      --                 , 'n');

      p_template  := 'DECLARE ' || l_declare || ' BEGIN tePLSQL.p(q''[' || p_template || ' ]''); END;';

   END interpret;

   /**
   * Search for include directives, includes and evaluates the specified templates.
   * Nested include are allowed
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE get_includes (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array )
    AS
       l_tmp             CLOB;
       l_result          CLOB;

       l_str_tmp         VARCHAR2 (64);

       TYPE array_t IS TABLE OF VARCHAR2 (64);

       l_strig_tt        array_t;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);

       l_start           PLS_INTEGER := 0;
       l_end             PLS_INTEGER := 0;
       l_number_includes PLS_INTEGER := 0;
    BEGIN
       /*
       --Pseudocode
       while there includes
       do
           get include
           interpret template
           concatenate result template into p_template
       done
       */
       WHILE REGEXP_INSTR (p_template, '<%@ include\((.*?)\)\s*%>') <> 0
       LOOP
          --Init
          l_str_tmp   := NULL;
          l_object_name := NULL;
          l_template_name := NULL;
          l_object_type := NULL;
          l_schema    := NULL;
          l_tmp       := NULL;
          l_start     := 0;
          l_end       := 0;

          --get include directive
          l_str_tmp   :=
             REGEXP_SUBSTR (p_template
                          , '<%@ include\((.*?)\)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);

          IF LENGTH (l_str_tmp) > 0
          THEN
                 SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_str_tmp
                                                       , '[^,]+'
                                                       , 1
                                                       , LEVEL), '\s', '')
                             text
                   BULK   COLLECT
                   INTO   l_strig_tt
                   FROM   DUAL
             CONNECT BY   REGEXP_SUBSTR (l_str_tmp
                                       , '[^,]+'
                                       , 1
                                       , LEVEL) IS NOT NULL;

             --populate variables
             IF l_strig_tt.EXISTS (1)
             THEN
                l_template_name := l_strig_tt (1);
             END IF;

             IF l_strig_tt.EXISTS (2)
             THEN
                l_object_name := l_strig_tt (2);
             END IF;

             IF l_strig_tt.EXISTS (3)
             THEN
                l_object_type := l_strig_tt (3);
             END IF;

             IF l_strig_tt.EXISTS (4)
             THEN
                l_schema    := l_strig_tt (4);
             END IF;

             --get included template
             l_tmp       :=
                include (l_template_name
                       , l_object_name
                       , l_object_type
                       , l_object_type);

             --Interpret the template
             interpret (l_tmp, p_vars);


             l_tmp := ']''); '|| l_tmp ||' tePLSQL.p(q''[';

             --Start and End of the expression
             l_start     :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 0
                            , 'n');

             l_end       :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 1
                            , 'n');

             --concatenate result template into first template
             IF (NVL (l_start, 0) > 0)
             THEN
                DBMS_LOB.createtemporary (l_result, FALSE, DBMS_LOB.call);

                IF l_start > 1
                THEN
                   DBMS_LOB.COPY (l_result
                                , p_template
                                , l_start - 1
                                , 1
                                , 1);
                END IF;

                IF LENGTH (l_tmp) > 0
                THEN
                   DBMS_LOB.COPY (l_result
                                , l_tmp
                                , DBMS_LOB.getlength (l_tmp)
                                , DBMS_LOB.getlength (l_result) +1
                                , 1);
                END IF;

                --Añadimos el resto de la fuente a la varbiable resultado
                DBMS_LOB.COPY (l_result
                             , p_template
                             , DBMS_LOB.getlength (p_template)
                             , DBMS_LOB.getlength (l_result) +1
                             , l_end);
             END IF;


             p_template  := l_result;

             DBMS_LOB.freetemporary (l_result);
          END IF;

          l_number_includes := l_number_includes +1;
          if l_number_includes >= 50
          then
            raise_application_error (-20001, 'Too much include directive in the template, Recursive include?');
          end if;

       END LOOP;
    END get_includes;

   PROCEDURE PRINT (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END PRINT;

   PROCEDURE p (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END p;

   FUNCTION render (p_vars IN t_assoc_array DEFAULT null_assoc_array, p_template IN CLOB)
      RETURN CLOB
   AS
    l_template   CLOB := p_template;
    l_length pls_integer;
   BEGIN
      --Clear buffer
      g_buffer    := NULL;

      --Parse <% %> tags
      --parse (l_template);

      --Get Includes
      get_includes(l_template);

      --Interpret the template
      interpret(l_template, p_vars);

      --Code blocks directive
      l_template  :=
         REGEXP_REPLACE (l_template
                       , '<%([^%>].*?)%>'
                       , ']''); \1 tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --DBMS_OUTPUT.put_line (l_template);

      --Execute the template
      $if dbms_db_version.ver_le_10 $then
          --10g
          DECLARE
             v_upperbound   NUMBER;
             v_cur          INTEGER;
             v_sql          DBMS_SQL.varchar2a;
             v_ret          NUMBER;
          BEGIN
             v_upperbound := CEIL (DBMS_LOB.getlength (l_template) / 32767);

             FOR i IN 1 .. v_upperbound
             LOOP
                v_sql (i)   := DBMS_LOB.SUBSTR (l_template, -- clob statement
                                                  32767, -- amount
                                                  ( (i - 1) * 32767) + 1);
             END LOOP;

             v_cur       := DBMS_SQL.open_cursor;
             -- parse sql statement
             DBMS_SQL.parse (v_cur
                           , v_sql
                           , 1
                           , v_upperbound
                           , FALSE
                           , DBMS_SQL.native);
             -- execute
             v_ret       := DBMS_SQL.execute (v_cur);
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;

      $else
          -- 11g
          BEGIN
             EXECUTE IMMEDIATE l_template;
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;
      $end

      l_template  := g_buffer;
      g_buffer    := NULL;

      RETURN l_template;
   EXCEPTION
      WHEN OTHERS
      THEN
         raise_application_error (-20001, SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
   END render;


   FUNCTION process (p_vars            IN t_assoc_array DEFAULT null_assoc_array
                   , p_template_name   IN VARCHAR2 DEFAULT NULL
                   , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                   , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                   , p_schema          IN VARCHAR2 DEFAULT NULL )
      RETURN CLOB
   AS
      l_result       CLOB;
      l_template     CLOB;
   BEGIN
      --Get template
      l_template := include(p_template_name,p_object_name,p_object_type,p_schema);

      IF LENGTH (l_template) = 0
      THEN
         IF p_template_name IS NOT NULL
         THEN
            raise_application_error (-20002
                                   , 'Template ' || p_template_name || ' not found in object ' || UPPER (p_object_name));
         ELSE
            raise_application_error (-20002
                                   , 'The object ' || p_object_name || ' not has a template inside the "$if false $then"');
         END IF;
      END IF;

      --Render template
      l_result    := render (p_vars,l_template);
      RETURN l_result;
   END process;
END teplsql;
/

--
-- Definition for package TAPI_GEN2
--
CREATE OR REPLACE PACKAGE tapi_gen2 AUTHID CURRENT_USER
  AS

  /**
  * TAPI_GEN2
  * Generated by: Oscar Salvador Magallanes
  * Website: github.com/osalvador/tapiGen2
  * Created On: 16-JUL-2015
  */

  --Global public data structures
  SUBTYPE dbo_name_t IS VARCHAR2(30); -- Max size for a DB object name

  TYPE dbo_name_aat IS TABLE OF dbo_name_t;

  TYPE column_rt IS RECORD (
      table_name      user_tab_columns.table_name % TYPE,
      column_name     user_tab_columns.column_name % TYPE,
      nullable        user_tab_columns.nullable % TYPE,
      constraint_type user_constraints.constraint_type % TYPE
    );

  --Collection types (record)
  TYPE column_tt IS TABLE OF column_rt;

  TYPE constraint_tt IS TABLE OF user_constraints % ROWTYPE;

  /**
  * Create PL/SQL Table API
  *
  * @param     p_table_name              must be NOT NULL
  * @param     p_compile_table_api       TRUE for compile generated package, FALSE to DBMS_OUTPUT the source
  * @param     p_unique_key              If the table has no primary key, it indicates the column that will be used as a unique key
  * @param     p_created_by_col_name     Custom audit column
  * @param     p_created_date_col_name   Custom audit column
  * @param     p_modified_by_col_name    Custom audit column
  * @param     p_modified_date_col_name  Custom audit column
  * @param     p_raise_exceptions        TRUE to use logger for exception handling
  */
  PROCEDURE create_tapi_package(p_table_name             IN VARCHAR2,
                                p_compile_table_api      IN BOOLEAN  DEFAULT TRUE,
                                p_unique_key             IN VARCHAR2 DEFAULT NULL,
                                p_created_by_col_name    IN VARCHAR2 DEFAULT NULL,
                                p_created_date_col_name  IN VARCHAR2 DEFAULT NULL,
                                p_modified_by_col_name   IN VARCHAR2 DEFAULT NULL,
                                p_modified_date_col_name IN VARCHAR2 DEFAULT NULL,
                                p_raise_exceptions       IN BOOLEAN  DEFAULT FALSE);

  --Public functions but for internal use.
  FUNCTION get_all_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

  FUNCTION get_pk_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

  FUNCTION get_noblob_columns(p_tab_name VARCHAR2)
    RETURN column_tt;

--Spec Template
$if false $then
<%@ template
    name=spec
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_cont in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_cont > 1
         then
               teplsql.p(p_delimiter);
         end if;
    end; %>
CREATE OR REPLACE PACKAGE tapi_${table_name}
IS
   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   <% for i in 1 .. col.last loop %>
   SUBTYPE <%= col(i).COLUMN_NAME%> IS ${table_name}.<%= col(i).COLUMN_NAME%>%TYPE;
   <% end loop; %>

   --Record type
   TYPE ${table_name}_rt
   IS
      RECORD (
           <% c := col.last+1;
           for i in 1 .. col.last loop %>
            <%=  col(i).COLUMN_NAME%> ${table_name}.<%=col(i).COLUMN_NAME %>%TYPE,
           <% end loop; %>
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE ${table_name}_tt IS TABLE OF ${table_name}_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   FUNCTION hash (
              <% c := pk.last+1;
                for i in 1 .. pk.last loop %>
                  p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
             <% end loop; %>
               )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the ${table_name} table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt_for_update (
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
                      <% end loop; %>
                          )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   * This function return Record Table as PIPELINED Function
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Table Record Type
   */
   FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
               )
   RETURN ${table_name}_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the ${table_name} table.
   *
   * @param      p_${table_name}_rec       Record Type
   * @return     p_${table_name}_rec       Record Type
   */
   PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table.
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table,
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   PROCEDURE del (
              <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_${table_name};
$end


--Body Template
$if false $then
<%@ template
    name=body
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! noblob   tapi_gen2.column_tt := tapi_gen2.get_noblob_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_index in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_index > 1
         then
            teplsql.p(p_delimiter);
         end if;
    end; %>
<%! /*  User column for update */
   procedure column_for_update(p_column_name in varchar2,
                               p_ignore_nulls in boolean,
                               p_index in pls_integer,
                               p_blanks in pls_integer default 16)
   as
    l_blanks varchar2(256);
   begin
     for i in 1 .. p_blanks
     loop
        l_blanks := l_blanks ||' ';
     end loop;

      if ('${created_by_col_name}' <> p_column_name or '${created_by_col_name}' is null)
        and ('${created_date_col_name}' <> p_column_name or '${created_date_col_name}' is null)
     then
        if '${modified_by_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = USER /*dbax_core.g$username or apex_application.g_user*/');
        elsif '${modified_date_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = SYSDATE');
        else
           if p_ignore_nulls
           then
            teplsql.p(p_column_name || ' = ' || 'NVL(p_${table_name}_rec.'|| p_column_name ||','|| p_column_name ||')');
           else
            teplsql.p(p_column_name || ' = p_${table_name}_rec.' || p_column_name);
           end if;
        end if;

        sep(p_index,',\\n' || l_blanks);

     end if;
   end; %>
CREATE OR REPLACE PACKAGE BODY tapi_${table_name} IS

   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

  <% if '${raise_exceptions}' is not null then %>
    --Global logger scope
    gc_scope_prefix CONSTANT varchar2(31) := LOWER($$plsql_unit)||'.';
  <% end if; %>

   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ${table_name}_cur (
                    <% c := pk.last+1; for i in 1 .. pk.last loop %>
                       p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                    <% end loop; %>
                       )
   IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
            <%=col(i).column_name%>,
        <% end loop; %>
            tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
            ROWID
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = ${table_name}_cur.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

    --By Rowid
    CURSOR ${table_name}_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
             <%=col(i).column_name%>,
        <% end loop; %>
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             ROWID
      FROM ${table_name}
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                <% end loop; %>
                  )
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN

     <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
     <% end if; %>

     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
         <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = hash.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <%end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);
      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <%end if; %>
   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN
      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
      <% end if; %>

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
          <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <% end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>
      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END hash_rowid;

   FUNCTION rt (
            <% c := pk.last+1; for i in 1 .. pk.last loop %>
               p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
            <% end loop; %>
               )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt.p_<%=pk(i).column_name%><%sep(c-i,' AND ' );%>\\n
        <% end loop; %>
           ;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt;

   FUNCTION rt_for_update (
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                        <% end loop; %>
                          )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt_for_update';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt_for_update.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt_for_update;

    FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
                )
       RETURN ${table_name}_tt
       PIPELINED
    IS
       <% if '${raise_exceptions}' is not null then %>
       l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'tt';
       l_params logger.tab_param;
       <% end if; %>
       l_${table_name}_rec   ${table_name}_rt;
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', tt.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ${table_name} a
                   WHERE
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                        <%=pk(i).column_name%> = NVL(tt.p_<%=pk(i).column_name%>,<%=pk(i).column_name%>)<%sep(c-i,' AND ');%>\\n
                      <% end loop; %>
                        )
       LOOP
            <% for i in 1 .. col.last loop %>
              l_${table_name}_rec.<%=col(i).column_name%> := c1.<%=col(i).column_name%>;
            <% end loop; %>
              l_${table_name}_rec.hash := tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %> c1.<%=pk(i).column_name%><%sep(c-i,',');%><% end loop; %>);
              l_${table_name}_rec.row_id := c1.ROWID;
              PIPE ROW (l_${table_name}_rec);
       END LOOP;
       <% if '${raise_exceptions}' is not null then %>

       logger.LOG('END', l_scope);
       <% end if; %>

       RETURN;

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
    <% end if; %>
    END tt;


    PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt)
    IS
        <% if '${raise_exceptions}' is not null then %>
        l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'ins';
        l_params logger.tab_param;
       <% end if; %>
        l_rowtype     ${table_name}%ROWTYPE;
       <% if '${created_by_col_name}' is not null
        or   '${modified_by_col_name}' is not null
       then
            if '${created_by_col_name}' is not null
            then%>
        l_user_name   ${table_name}.${created_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <%else%>
        l_user_name   ${table_name}.${modified_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <% end if;
       end if;
       if '${created_date_col_name}' is not null
       or '${modified_date_col_name}' is not null
       then
            if '${created_date_col_name}' is not null
            then %>
        l_date        ${table_name}.${created_date_col_name}%TYPE := SYSDATE;
            <%else%>
        l_date        ${table_name}.${modified_date_col_name}%TYPE := SYSDATE;
            <% end if;
       end if; %>

    BEGIN
        <% if '${raise_exceptions}' is not null then
          for i in 1 .. col.last loop %>
        logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', ins.p_${table_name}_rec.<%=col(i).column_name%>);
        <% end loop; %>
        logger.LOG('START', l_scope, NULL, l_params);
        logger.LOG('Inserting data', l_scope);
        <% end if;%>

        <% if '${created_by_col_name}'Is not null then%>
        p_${table_name}_rec.${created_by_col_name} := l_user_name;
        <% end if; %>!\n
        <% if '${created_date_col_name}' is not null then %>
        p_${table_name}_rec.${created_date_col_name} := l_date;
        <% end if; %>!\n
        <% if '${modified_by_col_name}' is not null then %>
        p_${table_name}_rec.${modified_by_col_name} := l_user_name;
        <% end if;%>!\n
        <% if '${modified_date_col_name}' is not null then %>
        p_${table_name}_rec.${modified_date_col_name} := l_date;
        <% end if; %>

        <% for i in 1 .. col.last loop %>
        l_rowtype.<%=col(i).column_name%> := ins.p_${table_name}_rec.<%=col(i).column_name%>;
        <% end loop; %>

       INSERT INTO ${table_name}
         VALUES   l_rowtype;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
      WHEN OTHERS
      THEN
         logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
         RAISE;
    <% end if; %>
    END ins;

    PROCEDURE upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,false,c-i);
                 end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
      <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
      <% end if; %>
    END upd;


    PROCEDURE upd_rowid (
                         p_${table_name}_rec         IN ${table_name}_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,false,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END upd_rowid;

   PROCEDURE web_upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                             web_upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                        <% end loop; %>
                        );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,true,c-i, 23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            END IF;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_${table_name}_rec    IN ${table_name}_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_upd_rowid.p_${table_name}_rec.row_id);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,true,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            END IF;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd_rowid;

    PROCEDURE del (
               <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
               <% end loop; %>
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

       DELETE FROM   ${table_name}
             WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  <%=pk(i).column_name%> = del.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
       <% if '${raise_exceptions}' is not null then %>
       logger.append_param(l_params, 'p_rowid', del_rowid.p_rowid);
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Deleting record', l_scope);
       <% end if; %>

       DELETE FROM   ${table_name}
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del_rowid;

    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', web_del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                          <% c := pk.last+1; for i in 1 .. pk.last loop %>
                            web_del.p_<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                          <% end loop; %>
                            );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_cur;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;


      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', web_del_rowid.p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_del_rowid.p_rowid);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_rowid_cur;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

     <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
     <%end if; %>
   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del_rowid;

END tapi_${table_name};

$end

END tapi_gen2;
/

CREATE OR REPLACE PACKAGE BODY tapi_gen2
  AS
  --Global private variables
  g_unque_key dbo_name_t;

  PROCEDURE create_tapi_package(p_table_name             IN VARCHAR2,
                                p_compile_table_api      IN BOOLEAN  DEFAULT TRUE,
                                p_unique_key             IN VARCHAR2 DEFAULT NULL,
                                p_created_by_col_name    IN VARCHAR2 DEFAULT NULL,
                                p_created_date_col_name  IN VARCHAR2 DEFAULT NULL,
                                p_modified_by_col_name   IN VARCHAR2 DEFAULT NULL,
                                p_modified_date_col_name IN VARCHAR2 DEFAULT NULL,
                                p_raise_exceptions       IN BOOLEAN  DEFAULT FALSE)
  AS
    l_count      PLS_INTEGER := 0;
    l_table_name dbo_name_t  := LOWER(p_table_name);
    l_vars       teplsql.t_assoc_array;
    l_spec_tapi  CLOB;
    l_body_tapi  CLOB;
  BEGIN
    /*Validations*/

    --check_table_exists
    SELECT COUNT(*)
      INTO l_count
      FROM user_tables
      WHERE UPPER(table_name) = UPPER(l_table_name);

    IF l_count = 0
    THEN
      RAISE_APPLICATION_ERROR(-20000, 'Table ' || l_table_name || ' does not exist!');
    END IF;

    --Check table hash PK or p_unique_key is not null
    IF p_unique_key IS NULL
    THEN
      SELECT COUNT(*)
        INTO l_count
        FROM user_constraints
        WHERE UPPER(table_name) = UPPER(l_table_name)
          AND constraint_type = 'P';

      IF l_count = 0
      THEN
        RAISE_APPLICATION_ERROR(-20000
        , 'Table '
        || l_table_name
        || ' does not have a Primary Key'
        || ' and P_UNIQUE_KEY parameter is null');
      END IF;
    END IF;

    --Init variables for render template
    l_vars('date') := TO_CHAR(sysdate, 'DD-MON-YYYY HH24:MI');
    l_vars('table_name') := l_table_name;
    l_vars('user') := USER;
    l_vars('created_by_col_name') := p_created_by_col_name;
    l_vars('created_date_col_name') := p_created_date_col_name;
    l_vars('modified_by_col_name') := p_modified_by_col_name;
    l_vars('modified_date_col_name') := p_modified_date_col_name;
    l_vars('result_cache') := 'RESULT_CACHE';

    IF p_raise_exceptions
    THEN
      l_vars('raise_exceptions') := 'TRUE';
    ELSE
      l_vars('raise_exceptions') := '';
    END IF;

    --If the table hash LOBS columns, disable result_cache.
    FOR c1 IN (SELECT *
        FROM user_tab_cols
        WHERE table_name = UPPER(l_table_name)
          AND data_type IN ('BLOB', 'CLOB'))
    LOOP
      l_vars('result_cache') := '';
    END LOOP;

    --Define unique key if table don't hace primary key
    g_unque_key := p_unique_key;

    -- Spec --
    --Process template
    l_spec_tapi := teplsql.process(l_vars, 'spec', 'TAPI_GEN2');

    -- Body --
    --Process template
    l_body_tapi := teplsql.process(l_vars, 'body', 'TAPI_GEN2');

    IF p_compile_table_api
    THEN
      BEGIN
        EXECUTE IMMEDIATE l_spec_tapi;
      EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(l_spec_tapi);
            RAISE_APPLICATION_ERROR(-20000, 'Spec compiled with error(s)! ' || sqlerrm);
      END;

      BEGIN
        EXECUTE IMMEDIATE l_body_tapi;
      EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20000, ' Body compiled with error(s)! ' || sqlerrm);
      END;

      dbms_output.put_line('Creation of Table API package for ' || l_table_name || ' table completed successfully!');
    ELSE
      dbms_output.put_line(l_spec_tapi);
      dbms_output.put_line(l_body_tapi);
    END IF;
  END create_tapi_package;


  FUNCTION get_all_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    SELECT c.table_name,
           LOWER(c.column_name),
           c.nullable,
           '' constraint_type
      BULK COLLECT
      INTO l_tt
      FROM user_tab_columns c
      WHERE c.table_name = UPPER(p_tab_name)
      ORDER BY c.column_id;

    RETURN l_tt;
  END;

  FUNCTION get_pk_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    IF g_unque_key IS NOT NULL
    THEN
      IF NOT l_tt.EXISTS(1)
      THEN
        l_tt := column_tt(NULL);
      END IF;

      l_tt(1).table_name := p_tab_name;
      l_tt(1).column_name := LOWER(g_unque_key);
      l_tt(1).nullable := 'N';
      l_tt(1).constraint_type := 'P';
    ELSE
      SELECT c.table_name,
             LOWER(c.column_name),
             c.nullable,
             cs.constraint_type
        BULK COLLECT
        INTO l_tt
        FROM user_tab_columns c
          LEFT JOIN user_cons_columns cc
            ON c.table_name = cc.table_name
            AND c.column_name = cc.column_name
            LEFT JOIN user_constraints cs
              ON cc.constraint_name = cs.constraint_name
        WHERE c.table_name = UPPER(p_tab_name)
          AND cs.constraint_type = 'P'
        ORDER BY c.column_id;
    END IF;

    RETURN l_tt;
  END;


  FUNCTION get_noblob_columns(p_tab_name VARCHAR2)
    RETURN column_tt
  IS
    l_tt column_tt;
  BEGIN
    SELECT c.table_name,
           LOWER(c.column_name),
           c.nullable,
           '' constraint_type
      BULK COLLECT
      INTO l_tt
      FROM user_tab_columns c
      WHERE table_name = UPPER(p_tab_name)
        AND column_name NOT IN (SELECT column_name
            FROM user_tab_cols
            WHERE table_name = UPPER(p_tab_name)
              AND data_type = 'BLOB')
      ORDER BY column_id;

    RETURN l_tt;
  END;
END tapi_gen2;

/

--
-- Definition for procedure LOGGER_CONFIGURE
--
CREATE OR REPLACE PROCEDURE logger_configure
IS
  -- Note: The license is defined in the package specification of the logger package
  --
  l_rac_lt_11_2          VARCHAR2(50)   := 'FALSE';  -- is this a RAC instance less than 11.2, no GAC support

  l_apex                 VARCHAR2(50)   := 'FALSE';
  tbl_not_exist          EXCEPTION;
  pls_pkg_not_exist      EXCEPTION;

  l_text_data_length     user_tab_columns.data_length % TYPE;
  l_large_text_column    VARCHAR2(50);

  l_sql                  VARCHAR2(32767);
  l_variables            VARCHAR2(1000) := ' ';
  l_dummy                NUMBER;
  l_flashback            VARCHAR2(50)   := 'FALSE';
  l_utl_lms              VARCHAR2(5)    := 'FALSE';

  PRAGMA EXCEPTION_INIT (tbl_not_exist, -942);
  PRAGMA EXCEPTION_INIT (pls_pkg_not_exist, -06550);

  l_version     CONSTANT NUMBER         := dbms_db_version.version + (dbms_db_version.release / 10);
  l_pref_value           logger_prefs.pref_value % TYPE;
  l_logger_debug         BOOLEAN;

  l_pref_type_logger     logger_prefs.pref_type % TYPE;
BEGIN

  -- Check to see if we are in a RAC Database, 11.1 or lower.
  --
  -- Tyler to check if this works
  IF dbms_utility.is_cluster_database
  THEN
    l_rac_lt_11_2 := 'TRUE';
  ELSE
    l_rac_lt_11_2 := 'FALSE';
  END IF;

  IF l_version >= 11.2
  THEN
    l_rac_lt_11_2 := 'FALSE';
  END IF;

  l_variables := 'RAC_LT_11_2:' || l_rac_lt_11_2 || ',';


  -- Check lenth of TEXT size (this is for future 12c 32767 integration
  -- In support of Issue #17 and future proofing for #30
  SELECT data_length
    INTO l_text_data_length
    FROM user_tab_columns
    WHERE 1 = 1
      AND table_name = 'LOGGER_LOGS'
      AND column_name = 'TEXT';

  IF l_text_data_length > 4000
  THEN
    l_large_text_column := 'TRUE';
  ELSE
    l_large_text_column := 'FALSE';
  END IF;
  l_variables := l_variables || 'LARGE_TEXT_COLUMN:' || l_large_text_column || ',';


  -- Is APEX installed ?
  --
  BEGIN
    EXECUTE IMMEDIATE 'select 1 from apex_application_items where rownum = 1'
      INTO l_dummy;

    l_apex := 'TRUE';
  EXCEPTION
    WHEN tbl_not_exist THEN
        l_apex := 'FALSE';
    WHEN no_data_found THEN
        l_apex := 'TRUE';
  END;

  l_variables := l_variables || 'APEX:' || l_apex || ',';


  -- Can we call dbms_flashback to get the currect System Commit Number?
  --
  BEGIN
    EXECUTE IMMEDIATE 'begin :d := dbms_flashback.get_system_change_number; end; '
    USING OUT l_dummy;

    l_flashback := 'TRUE';
  EXCEPTION
    WHEN pls_pkg_not_exist THEN
        l_flashback := 'FALSE';
  END;

  l_variables := l_variables || 'FLASHBACK_ENABLED:' || l_flashback || ',';


  -- #64: Support to run Logger in debug mode

  -- #127
  -- Since this procedure will recompile Logger, if it directly references a variable in Logger
  -- It will lock itself while trying to recompile
  -- Work around is to pre-store the variable using execute immediate
  EXECUTE IMMEDIATE 'begin :x := logger.g_pref_type_logger; end;'
  USING OUT l_pref_type_logger;

  SELECT lp.pref_value
    INTO l_pref_value
    FROM logger_prefs lp
    WHERE 1 = 1
      AND lp.pref_type = UPPER(l_pref_type_logger)
      AND lp.pref_name = 'LOGGER_DEBUG';
  l_variables := l_variables || 'LOGGER_DEBUG:' || l_pref_value || ',';

  l_logger_debug := FALSE;
  IF UPPER(l_pref_value) = 'TRUE'
  THEN
    l_logger_debug := TRUE;
  END IF;


  -- #46
  -- Handle plugin settings
  -- Set for each plugin type
  FOR x IN (SELECT 'LOGGER_' ||
    REGEXP_REPLACE(lp.pref_name, '^PLUGIN_FN_', 'PLUGIN_') || ':' ||
    DECODE(NVL(UPPER(lp.pref_value), 'NONE'), 'NONE', 'FALSE', 'TRUE') ||
    ',' var
      FROM logger_prefs lp
      WHERE 1 = 1
        AND lp.pref_type = l_pref_type_logger
        AND lp.pref_name LIKE 'PLUGIN_FN%')
  LOOP
    l_variables := l_variables || x.var;
  END LOOP;


  l_variables := RTRIM(l_variables, ',');
  IF l_logger_debug
  THEN
    dbms_output.put_line('l_variables: ' || l_variables);
  END IF;


  -- Recompile Logger
  l_sql := q'!alter package logger compile body PLSQL_CCFLAGS='%VARIABLES%' reuse settings!';
  l_sql := REPLACE(l_sql, '%VARIABLES%', l_variables);
  EXECUTE IMMEDIATE l_sql;

  -- #31: Dropped trigger
  -- l_sql := q'[alter trigger BI_LOGGER_LOGS compile PLSQL_CCFLAGS=']'||l_variables||q'[' reuse settings]';
  -- execute immediate l_sql;

  l_sql := q'!alter trigger biu_logger_prefs compile PLSQL_CCFLAGS='CURRENTLY_INSTALLING:FALSE'!';
  EXECUTE IMMEDIATE l_sql;

  -- just in case this is a re-install / upgrade, the global contexts will persist so reset them
  logger.null_global_contexts;

END logger_configure;
/

--
-- Definition for view LOGGER_LOGS_5_MIN
--
CREATE OR REPLACE VIEW logger_logs_5_min (
  id,
  logger_level,
  text,
  time_stamp,
  scope,
  module,
  action,
  user_name,
  client_identifier,
  call_stack,
  unit_name,
  line_no,
  scn,
  extra,
  sid,
  client_info
) AS
    SELECT "ID",
           "LOGGER_LEVEL",
           "TEXT",
           "TIME_STAMP",
           "SCOPE",
           "MODULE",
           "ACTION",
           "USER_NAME",
           "CLIENT_IDENTIFIER",
           "CALL_STACK",
           "UNIT_NAME",
           "LINE_NO",
           "SCN",
           "EXTRA",
           "SID",
           "CLIENT_INFO"
      FROM logger_logs
      WHERE time_stamp > systimestamp - (5 / 1440);

--
-- Definition for view LOGGER_LOGS_60_MIN
--
CREATE OR REPLACE VIEW logger_logs_60_min (
  id,
  logger_level,
  text,
  time_stamp,
  scope,
  module,
  action,
  user_name,
  client_identifier,
  call_stack,
  unit_name,
  line_no,
  scn,
  extra,
  sid,
  client_info
) AS
    SELECT "ID",
           "LOGGER_LEVEL",
           "TEXT",
           "TIME_STAMP",
           "SCOPE",
           "MODULE",
           "ACTION",
           "USER_NAME",
           "CLIENT_IDENTIFIER",
           "CALL_STACK",
           "UNIT_NAME",
           "LINE_NO",
           "SCN",
           "EXTRA",
           "SID",
           "CLIENT_INFO"
      FROM logger_logs
      WHERE time_stamp > systimestamp - (1 / 24);

--
-- Definition for view LOGGER_LOGS_TERSE
--
CREATE OR REPLACE VIEW logger_logs_terse (
  id,
  logger_level,
  time_ago,
  text
) AS
    SELECT id,
           logger_level,
           SUBSTR(logger.date_text_format(time_stamp), 1, 20) time_ago,
           SUBSTR(text, 1, 200) text
      FROM logger_logs
      WHERE time_stamp > systimestamp - (5 / 1440)
      ORDER BY id ASC;

--
-- Dumping data for table LOGGER_LOGS
--
DECLARE
TMP_CLOB_13 CLOB := NULL;
SRC_CHUNK_13 VARCHAR2(12001);
BEGIN
INSERT INTO LOGGER_LOGS VALUES
(1, 8, 'Log level set to DEBUG for client_id: <global>, include_call_stack=TRUE by Host: WORKGROUP\TL-SIST03, IP: 127.0.0.1, TERMINAL: TL-SIST03, OS_USER: TL-SIST03\pjaraba, CURRENT_USER: SIMPLE_DELIVERY, SESSION_USER: SIMPLE_DELIVERY', '07/19/2016 12:46:10.065000000', NULL, 'SQL*Plus', NULL, 'SIMPLE_DELIVERY', NULL, NULL, NULL, NULL, NULL, NULL, 249, NULL);
INSERT INTO LOGGER_LOGS VALUES
(2, 1, 'Logger version 3.1.0 installed.', '07/19/2016 12:46:10.149000000', NULL, 'SQL*Plus', NULL, 'SIMPLE_DELIVERY', NULL, '  object      line  object'||CHR(10)
||'  handle    number  name'||CHR(10)
||'00007FFD1BC6C4E0         2  anonymous block'||CHR(10)
, NULL, NULL, NULL, NULL, 249, NULL);
END;
/

--
-- Dumping data for table LOGGER_PREFS
--
INSERT INTO LOGGER_PREFS VALUES
('LEVEL', 'DEBUG', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PURGE_MIN_LEVEL', 'DEBUG', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PROTECT_ADMIN_PROCS', 'TRUE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('LOGGER_VERSION', '3.1.0', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('LOGGER_DEBUG', 'FALSE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('INSTALL_SCHEMA', 'SIMPLE_DELIVERY', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('INCLUDE_CALL_STACK', 'TRUE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PLUGIN_FN_ERROR', 'NONE', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PURGE_AFTER_DAYS', '7', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('PREF_BY_CLIENT_ID_EXPIRE_HOURS', '12', 'LOGGER');
INSERT INTO LOGGER_PREFS VALUES
('GLOBAL_CONTEXT_NAME', 'SIMPLE_DELIVERY_LOGCTX', 'LOGGER');

--
-- Dumping data for table LOGGER_PREFS_BY_CLIENT_ID
--

-- Table SIMPLE_DELIVERY.LOGGER_PREFS_BY_CLIENT_ID does not contain any data (it is empty)

--
-- Dumping data for table TE_TEMPLATES
--

-- Table SIMPLE_DELIVERY.TE_TEMPLATES does not contain any data (it is empty)

--
-- Dumping data for table LOGGER_LOGS_APEX_ITEMS
--

-- Table SIMPLE_DELIVERY.LOGGER_LOGS_APEX_ITEMS does not contain any data (it is empty)

--
-- Definition for trigger BIU_LOGGER_APEX_ITEMS
--
CREATE OR REPLACE TRIGGER biu_logger_apex_items
  BEFORE INSERT OR UPDATE
  ON logger_logs_apex_items
  FOR EACH ROW
BEGIN
$if $$logger_no_op_install $then
  null;
$else
  :new.id := logger_apx_items_seq.nextval;
$end
END;

/

--
-- Definition for trigger BIU_LOGGER_PREFS
--
CREATE OR REPLACE TRIGGER biu_logger_prefs
  BEFORE INSERT OR UPDATE
  ON logger_prefs
  FOR EACH ROW
BEGIN
$if $$logger_no_op_install $then
  null;
$else
  :new.pref_name := upper(:new.pref_name);
  :new.pref_type := upper(:new.pref_type);

  if 1=1
    and :new.pref_type = logger.g_pref_type_logger
    and :new.pref_name = 'LEVEL' then
    :new.pref_value := upper(:new.pref_value);
  end if;

  $if $$currently_installing is null or not $$currently_installing $then
    -- Since logger.pks may not be installed when this trigger is compiled, need to move some code here
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name = 'LEVEL'
      and upper(:new.pref_value) not in (logger.g_off_name, logger.g_permanent_name, logger.g_error_name, logger.g_warning_name, logger.g_information_name, logger.g_debug_name, logger.g_timing_name, logger.g_sys_context_name, logger.g_apex_name) then
      raise_application_error(-20000, '"LEVEL" must be one of the following values: ' ||
        logger.g_off_name || ', ' || logger.g_permanent_name || ', ' || logger.g_error_name || ', ' ||
        logger.g_warning_name || ', ' || logger.g_information_name || ', ' || logger.g_debug_name || ', ' ||
        logger.g_timing_name || ', ' || logger.g_sys_context_name || ', ' || logger.g_apex_name);
    end if;

    -- Allow for null to be used for Plugins, then default to NONE
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name like 'PLUGIN_FN%'
      and :new.pref_value is null then
      :new.pref_value := 'NONE';
    end if;

    -- #103
    -- Only predefined preferences and Custom Preferences are allowed
    -- Custom Preferences must be prefixed with CUST_
    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name not in (
        'GLOBAL_CONTEXT_NAME'
        ,'INCLUDE_CALL_STACK'
        ,'INSTALL_SCHEMA'
        ,'LEVEL'
        ,'LOGGER_DEBUG'
        ,'LOGGER_VERSION'
        ,'PLUGIN_FN_ERROR'
        ,'PREF_BY_CLIENT_ID_EXPIRE_HOURS'
        ,'PROTECT_ADMIN_PROCS'
        ,'PURGE_AFTER_DAYS'
        ,'PURGE_MIN_LEVEL'
      )
    then
      raise_application_error (-20000, 'Setting system level preferences are restricted to a set list.');
    end if;

    -- this is because the logger package is not installed yet.  We enable it in logger_configure
    logger.null_global_contexts;
  $end
$end -- $$logger_no_op_install
END;

/

COMMIT;
--
-- Set default schema
--
DECLARE
  p VARCHAR2(255);
BEGIN
  SELECT USER INTO p FROM DUAL;
  EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = ' || p;
END;
/
